<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Top-Down</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="affix"><a href="index.html">Rust for OO Programmers</a></li><li class="affix"><a href="OVERVIEW.html">Overview from an OO Perspective</a></li><li class="affix"><a href="lessons/LESSONS.html">Lessons</a></li><li><a href="lessons/lesson_one/index.html"><strong aria-hidden="true">1.</strong> Setup And A Function</a></li><li><ol class="section"><li><a href="lessons/lesson_one/ex_function_parameter_return.html"><strong aria-hidden="true">1.1.</strong> Calling a Function</a></li></ol></li><li><a href="lessons/lesson_two/index.html"><strong aria-hidden="true">2.</strong> Standard Lib, Types, Immutability</a></li><li><a href="lessons/lesson_three/index.html"><strong aria-hidden="true">3.</strong> Intro to Traits</a></li><li><a href="lessons/lesson_four/index.html"><strong aria-hidden="true">4.</strong> Enum Wrappers, Option and Matching</a></li><li><a href="lessons/lesson_five/index.html"><strong aria-hidden="true">5.</strong> Error Handling</a></li><li><a href="lessons/lesson_six/index.html"><strong aria-hidden="true">6.</strong> Almighty Iterators</a></li><li><a href="lessons/lesson_seven/index.html"><strong aria-hidden="true">7.</strong> Housekeeping #1</a></li><li><a href="lessons/lesson_eight/index.html"><strong aria-hidden="true">8.</strong> Closures and Lifetime Preview</a></li><li><a href="lessons/lesson_nine/index.html"><strong aria-hidden="true">9.</strong> Lifetime Annotations</a></li><li><a href="lessons/lesson_ten/index.html"><strong aria-hidden="true">10.</strong> Unit Testing</a></li><li><a href="lessons/lesson_eleven/index.html"><strong aria-hidden="true">11.</strong> TBD</a></li><li><a href="lessons/lesson_twelve/index.html"><strong aria-hidden="true">12.</strong> Trait Bounds</a></li><li><a href="lessons/lesson_thirteen/index.html"><strong aria-hidden="true">13.</strong> Constructor Patterns</a></li><li><a href="lessons/lesson_fourteen/index.html"><strong aria-hidden="true">14.</strong> Iterator Patterns</a></li><li><a href="lessons/lesson_fifteen/index.html"><strong aria-hidden="true">15.</strong> Copy/Clone/Sized Traits</a></li><li><a href="lessons/lesson_sixteen/index.html"><strong aria-hidden="true">16.</strong> Closure Patterns</a></li><li><a href="lessons/lesson_seventeen/index.html"><strong aria-hidden="true">17.</strong> Reference Counting and Interior Mutability with RefCell and Rc</a></li><li><a href="lessons/lesson_eighteen/index.html"><strong aria-hidden="true">18.</strong> Bit Fiddling</a></li><li><a href="lessons/lesson_nineteen/index.html"><strong aria-hidden="true">19.</strong> Web Assembly - WASM</a></li><li><a href="lessons/lesson_twenty/index.html"><strong aria-hidden="true">20.</strong> Threads</a></li><li><a href="lessons/lesson_twenty_one/index.html"><strong aria-hidden="true">21.</strong> Async Essentials</a></li><li><a href="lessons/lesson_twenty_two/RustFSExample/index.html"><strong aria-hidden="true">22.</strong> File I/O and Image Transformations</a></li><li><a href="lessons/lesson_twenty_three/index.html"><strong aria-hidden="true">23.</strong> Unsafe Code</a></li><li class="affix"><a href="misc/contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Rust Top-Down</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#rust-top-down" id="rust-top-down">Rust Top-Down</a></h1>
<p>This is an overview/tutorial of the Rust programming language for progrmamers coming from 'higher' level languages.</p>
<p>Rust is best groked from a C++/C perspective, so some content that attends to the background of programmers with Java/.NET/Python backgrounds lets us skip a few topics, but more importantly post warning signs where OO thinking may introduce obstacles to success. </p>
<p><a href="https://doc.rust-lang.org/book/">The Rust Programming Language - aka 'The Book'</a> is a <em>great</em> resource and should certainly be used in conjuction with the content if you are new to Rust programming.</p>
<p>Rust code and libraries are also easily 'self-documented', and one of the best examples is the <code>std</code> crate.  (a <code>crate</code> being the equivilant of an npm or nuget package).  <a href="https://doc.rust-lang.org/std/">std</a>  For core concepts (e.g. references, types, etc.), the api documentation often provides conceptual context that is very helpful. </p>
<p>A personal favorite, though sparse in parts, is the [reference book].(https://doc.rust-lang.org/stable/reference/) It's readable and not strictly a formal reference.</p>
<p>Keep in mind that post-install, you have the core documentation installed locally.  Launch with <code>rustup doc</code></p>
<h2><a class="header" href="#how-to-use" id="how-to-use">How to Use</a></h2>
<ul>
<li>
<p>The content/progress is fairly linear.</p>
</li>
<li>
<p>The README for each chapter explains concepts and then typically presents an exercise.</p>
</li>
<li>
<p>If you fork or clone this repository, most of the exercises are in the /src folder.</p>
</li>
<li>
<p>You know how you learn best, but taking the examples, tweeking them, and playing with the problem/topics works well for most. </p>
</li>
<li>
<p>The original content was developed as part of an in-house course on Rust, and is a WIP, so some oddities may appear. </p>
</li>
</ul>
<h2><a class="header" href="#objectives" id="objectives">Objectives</a></h2>
<ul>
<li>Provide an introduction to Rust that will get you moving, quickly</li>
<li>Keep the lessons small and focused, one or two topics, max</li>
<li>Build a solid foundation in Rust for further development</li>
<li>Provide contextual information for OO programmers looking for a frame of reference</li>
</ul>
<h2><a class="header" href="#other-notes-and-tips" id="other-notes-and-tips">Other Notes and Tips</a></h2>
<ul>
<li>Resist the temptation to skim the Rust documention, jump over to github, pull a random project and start compiling.  A good foundation will get you moving faster.</li>
<li>Rust code can be a bit intimidating at first glance (and even after a few more glances). However you're not obliged to use the advanced features of the language to get moving.  There are solid applications and libraries that are light on generics, inter-thread communication, macros, unsafe code, etc.</li>
</ul>
<h1><a class="header" href="#the-oo-perspective" id="the-oo-perspective">The OO Perspective</a></h1>
<p>For the OO programmer, a few things about Rust stand out:</p>
<ul>
<li>Functionality (often traits), is decoupled from data structures (structs or enums). </li>
<li>&quot;You get what you get&quot; - there's very little in the way of 'inherited' functionality.</li>
<li>There is no NULL.  It is replaced, by convention, by wrapping <code>None</code> in an <code>Option&lt;T&gt;</code></li>
<li>You're accountable for the memory life of your allocations, though Rust, through compile-time rules, assists, vigorously. </li>
<li>Iteration and closures are first-class citizens in code composition. </li>
<li>The allocation-related rules above have significant consequences, especially for recursive-types (e.g. graph nodes), associated types, and thread-safe types. </li>
</ul>
<p>Some of the language's appeal:</p>
<ul>
<li>A garbage-collection free, lightweight runtime that is memory safe.</li>
<li>Incredible performance.</li>
<li>Generics</li>
<li>Fearless concurrency</li>
</ul>
<h1><a class="header" href="#lessons" id="lessons">Lessons</a></h1>
<table><thead><tr><th>Lesson</th><th>Content</th></tr></thead><tbody>
<tr><td>Lesson One</td><td><a href="lessons/lesson_one">Setup and passing/returning String</a></td></tr>
<tr><td>Lesson Two</td><td>Standard Lib, Types, Immutability</td></tr>
<tr><td>Lesson Three</td><td>Introduction To Traits</td></tr>
<tr><td>Lesson Four</td><td>Enum Wrappers, Option<T>, and Matching</td></tr>
<tr><td>Lesson Five</td><td>Error Handling Basics</td></tr>
<tr><td>Lesson Six</td><td>Loops and Almighty Iterators</td></tr>
<tr><td>Lesson Seven</td><td>Housekeeping (proj structure, some new types, etc.)</td></tr>
<tr><td>Lesson Eight</td><td>Closures and a Peek at Lifetimes</td></tr>
<tr><td>Lesson Nine</td><td>Lifetimes</td></tr>
<tr><td>Lesson Ten</td><td>Unit Testing</td></tr>
<tr><td>Lesson Eleven</td><td>TBD</td></tr>
<tr><td>Lesson Twelve</td><td>Trait Bounds</td></tr>
<tr><td>Lesson Thirteen</td><td>Patterns of Constructors</td></tr>
<tr><td>Lesson Fourteen</td><td>Patterns of Iterators</td></tr>
<tr><td>Lesson Fifteen</td><td>The Copy, Clone and Sized Traits</td></tr>
<tr><td>Lesson Sixteen</td><td>and returning Traits</td></tr>
<tr><td>Lesson Seventeen</td><td>Functions vs. methods and impl on structs</td></tr>
<tr><td>Lesson Eighteen</td><td>Slices in Retrospect</td></tr>
<tr><td>Lesson Nineteen</td><td>Web Assembly (WASM)</td></tr>
<tr><td>Lesson 20</td><td>The Sized Trait</td></tr>
<tr><td>Lesson 21</td><td>Environment variables and the command line</td></tr>
<tr><td>Lesson 22</td><td>File I/O and Serde</td></tr>
<tr><td>Lesson 23</td><td>Ref Stuff</td></tr>
<tr><td>Lesson 24</td><td>Associated types on traits</td></tr>
<tr><td>Lesson 25</td><td>The Sized Trait</td></tr>
<tr><td>Lesson 26</td><td>Housekeeping Part 3</td></tr>
<tr><td>Lesson 27</td><td>Web (and other) Assembly</td></tr>
<tr><td>Lesson 28</td><td>TBD</td></tr>
<tr><td>Lesson 29</td><td>Futures</td></tr>
<tr><td>Lesson 30</td><td>Pluggable Runtimes and Async/Await</td></tr>
</tbody></table>
<h1><a class="header" href="#lesson-one-setup-and-returning-a-string" id="lesson-one-setup-and-returning-a-string">Lesson One: Setup and returning a String</a></h1>
<h2><a class="header" href="#objectives-1" id="objectives-1">Objectives</a></h2>
<ul>
<li>Get Rust installed</li>
<li>Look at the toolchain (rustc, cargo, rustup)</li>
<li>Create a function that returns a value</li>
</ul>
<h3><a class="header" href="#installing" id="installing">Installing</a></h3>
<p><a href="https://www.rust-lang.org/">Installing Rust</a> - This installs the toolchain (compiler and package manager (cargo) - Windows, OSX, Linux and other OS's are supported.</p>
<ul>
<li>Verify your installation worked by opening a command/terminal prompt and typing:</li>
</ul>
<pre><code>rustup
rustc
cargo
</code></pre>
<h3><a class="header" href="#get-to-know-the-toolchain" id="get-to-know-the-toolchain">Get to Know the toolchain</a></h3>
<p>rustc is the compiler, but it's normally called by running a 'cargo' command (e.g. cargo build)</p>
<p>This command:</p>
<pre><code>rustup show
</code></pre>
<p>shows you your default / active toolchain.  Something like:</p>
<pre><code>installed toolchains
--------------------

stable-x86_64-unknown-linux-gnu (default)
nightly-x86_64-unknown-linux-gnu

active toolchain
----------------

stable-x86_64-unknown-linux-gnu (default)
rustc 1.37.0 (eae3437df 2019-08-13)
</code></pre>
<p>You can switch the active toolchain or compile with a specific toolchain.  Look at the 'rustup' command for details. </p>
<h4><a class="header" href="#cool-note" id="cool-note">Cool Note</a></h4>
<p>Type <code>rustc</code>, and look at the option for <code>emit</code> that specifies the output format, including asm (assembly) and llvm-ir </p>
<pre><code>--emit [asm|llvm-bc|llvm-ir|obj|metadata|link|dep-info|mir]
                        Comma separated list of types of output for the
                        compiler to emit
</code></pre>
<h3><a class="header" href="#tool-summary" id="tool-summary">Tool Summary</a></h3>
<p>So, there are three tools to get straight:</p>
<table><thead><tr><th>Tool</th><th>Purpose</th></tr></thead><tbody>
<tr><td><code>rustup</code></td><td>Doc and toolchain related</td></tr>
<tr><td><code>cargo</code></td><td>Rust project builder, runner, invoker sort of like ~npm</td></tr>
<tr><td><code>rustc</code></td><td>The rust compiler, though you will likely invoke it via <code>cargo</code></td></tr>
</tbody></table>
<h2><a class="header" href="#launch-the-local-doc" id="launch-the-local-doc">Launch the Local Doc</a></h2>
<p>You're going to need it.  ;)</p>
<p><code>rustup doc</code></p>
<h2><a class="header" href="#review-the-cargotoml" id="review-the-cargotoml">Review the Cargo.toml</a></h2>
<p>Take a look at the format of the Cargo.toml.  That's the package.json / .proj  manifest file for Rust.</p>
<p>The most important part is the 'dependencies' section.  There are dependencies and dev-dependencies and many other options  <a href="https://rurust.github.io/cargo-docs-ru/manifest.html">Rust manifest</a> </p>
<h2><a class="header" href="#exercises" id="exercises">Exercises</a></h2>
<p>You have some choices on runnning the exercises:</p>
<ul>
<li>Run inside of the doc via playpen (look for the play button)</li>
<li>Clone or fork this repository and navigate to the lesson directory and run with <code>cargo run</code> </li>
<li>Brew your own repo, optionally copying-pasting code</li>
</ul>
<table><thead><tr><th>Exercise</th><th>Purpose</th></tr></thead><tbody>
<tr><td><a href="lessons/lesson_one/ex_function_parameter_return.html">Calling a Function</a></td><td>Kicking the Tires</td></tr>
</tbody></table>
<h2><a class="header" href="#calling-a-function" id="calling-a-function">Calling a Function</a></h2>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let name = &quot;Rustican&quot;;
    let function_result = greetings(name);
    println!(&quot;{}&quot;, function_result);
}

fn greetings(name: &amp;str) -&gt; String {
    &quot;Hello &quot;.to_string() + name
}
</code></pre></pre>
<p>Try running this with the play button above.</p>
<h4><a class="header" href="#code-dissection" id="code-dissection">Code Dissection</a></h4>
<p>Two elements jump out here: <code>println!</code> and <code>&amp;str</code>:</p>
<p>One-by-one: </p>
<p>The <code>println!</code></p>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
println!(function_result);
#}</code></pre></pre>
<p>The println! 'function' lives in <a href="https://doc.rust-lang.org/std/macro.println.html">std::io::println</a> But, it's not a function, it's a macro. </p>
<p>The little '!' at the end of println is not 'not.' It means it's a macro. </p>
<p>A macro is a meta-code generation feature that lets macro authors expand simple syntax (hopefully), into something that would otherwise be unduly complex or repetitive. </p>
<p>A macro author writes the rules (the macro) for the expansion.</p>
<p>You needn't author macros to code in Rust, but you will use them.</p>
<br>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
fn greetings(name: &amp;str) -&gt; String 
#}</code></pre></pre>
<p>The <code>&amp;str</code></p>
<ul>
<li>There are two string types in Rust. <a href="https://doc.rust-lang.org/rust-by-example/std/str.html">Rust Strings</a></li>
<li>The <code>&amp;str</code> type is a string slice.  It's a pointer to some UTF-8 bytes, so we know it's length, precisely.</li>
<li>The <code>String</code> type is dynamically sized, and is conceptually close to a Java or .NET String class.</li>
</ul>
<p>The challenge is that we frequently move back and forth between the two.</p>
<p>The secret-sauce of Rust, compile-time checks, requires that all types allocated have a known-size.  Consequently, many of the operations on strings are done on the <code>&amp;str</code> type and there are reasons (forthcoming) to prefer the &amp;str as a parameter. </p>
<p>So, in the code:</p>
<ul>
<li><code>name</code> is actually a string slice <code>&amp;str</code> and is passed accordingly to the <code>greetings</code> function</li>
<li>The <code>to_string</code> function makes our <code>&amp;str</code> a String.  (Think to_String() with a big S). </li>
<li>Our concatenation operator <code>+</code> takes a <code>&amp;str</code> and a <code>String</code> and returns a <code>String</code>.</li>
<li>That String is returned and used as the parameter to the println! macro. </li>
</ul>
<p>Again:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let name = &quot;Rustican&quot;;
    let function_result = greetings(name);
    println!(&quot;{}&quot;, function_result);
}

fn greetings(name: &amp;str) -&gt; String {
    &quot;Hello &quot;.to_string() + name
}
</code></pre></pre>
<h3><a class="header" href="#implicit-return" id="implicit-return">Implicit Return</a></h3>
<p>The <code>return</code> keyword is not specified and <code>;</code> is not required in this case. </p>
<p>This works: </p>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
fn return_something() -&gt; i32 {
    1
} 
#}</code></pre></pre>
<p>But, this fails to compile (but would with a <code>return 1;</code> statement)</p>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
fn return_something() -&gt; i32 {
    1;
} 
#}</code></pre></pre>
<h4><a class="header" href="#task" id="task">Task</a></h4>
<p>Play around with the code block.  Don't worry if you hit errors at this point.</p>
<h1><a class="header" href="#lesson-two-the-standard-library-basic-types-and-immutability" id="lesson-two-the-standard-library-basic-types-and-immutability">Lesson Two: The Standard Library, Basic Types and Immutability</a></h1>
<h2><a class="header" href="#objectives-2" id="objectives-2">Objectives</a></h2>
<ul>
<li>Understand basic variable assignments, types and fundamental borrowing rules </li>
<li>Understand what the standard library is and when it might not be used</li>
</ul>
<h2><a class="header" href="#the-foundation-we-are-standing-on-normally-std" id="the-foundation-we-are-standing-on-normally-std">The Foundation We are Standing on (normally): std</a></h2>
<p>Take a look at the Rust standard library <a href="https://doc.rust-lang.org/std/">std</a> </p>
<p>Normally, we'll be using the standard library but it's not required. Embedded devices, may or may not have a file system, for example, and sans std lib, we can stillwcode Rust for those devices. </p>
<p>Libraries or binaries/executables with:</p>
<pre><code>#![no_std]
</code></pre>
<p>instruct the compiler to reject any use of the standard library.</p>
<p>Some good resources on embedded programming with Rust:</p>
<ul>
<li>[Discover embedded programming with Rust (good for getting started)] https://docs.rust-embedded.org/discovery/</li>
<li>[The Embedded Rust Book] (https://docs.rust-embedded.org/book/) </li>
</ul>
<h2><a class="header" href="#immutability" id="immutability">Immutability</a></h2>
<p>By default Rust values are immutable and the compiler enforces compliance.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 10;
x = 12;
#}</code></pre></pre>
<p>produces a compile error.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut x = 10;
x = 12;
#}</code></pre></pre>
<p>works because the variable is marked as mutable (changeable)</p>
<h2><a class="header" href="#race-conditions-fearless-concurrency-and-why-rust-helps" id="race-conditions-fearless-concurrency-and-why-rust-helps">Race Conditions, Fearless Concurrency and Why Rust Helps:</a></h2>
<p>Let's say we have a Point of Sales system, and there are many run-time configuration options/rules.  A developer writes some code and then updates those options.  Developer B, in a different module, does the same.  When those updating events are called, at runtime, is unknown, as it depends on the system users. That's a basic race condition.</p>
<p>Rust adds a bit of information to each memory allocation/variable - ownership.  Race conditions are not all bad (e.g. a multi-player game), but hidden race conditions are frequent source of bugs.  Rust's ownership and compile-time enforcement of ownership rules effectively 'outs' those race conditions.</p>
<p>Ownership is a central concept in Rust and all heap allocated data has an owner.  Changing ownership is called a 'Move'  Sharing of values is allowed.  Sharing a reference is called 'borrowing'.   Mutability comes in to play.</p>
<ol>
<li><code>MyVariable</code> can be borrowed by multiple borrowers.</li>
<li><code>mut MyVariable</code> can be borrowed by <em>one</em> borrower.</li>
</ol>
<p>The second rule is our guard against unwittingly introducing or exposing a race condition.</p>
<h2><a class="header" href="#chapter-for-from-the-book" id="chapter-for-from-the-book">Chapter for from The Book</a></h2>
<p>Chapter 4 from the Rust book has an excellent overview of this critical topic:
<a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html">The stack, heap, ownership and borrowing</a></p>
<h2><a class="header" href="#general-notes" id="general-notes">General Notes</a></h2>
<p>Borrowing gets us control over the scope and lifetime of memory allocations.  But, there is a price.  Recursive functions, when optimized, become an exercise in handling the borrows.  That's why a fibonacci sequence in a dynamically typed language can look like this:</p>
<p>(Lua)</p>
<pre><code class="language-lua">function fib(n)
 if n == 0 or n == 1 then
 return n
 else
 return fib(n - 1) + fib(n - 2)
end
</code></pre>
<p>and in Rust (albeit a complex, optimized form) look like this:</p>
<p>(Rust)</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn fib(n_dyn: Rc&lt;Any&gt;) -&gt; Rc&lt;Any&gt; {
 let n_static: &amp;i32 =
    n_dyn.downcast_ref::&lt;i32&gt;().unwrap();
    if *n_static == 0 {
        Rc::new(Box::new(*n_static))
    } else {
    let n1 = fib(Rc::new(Box::new(n_static - 1)));
    let n2 = fib(Rc::new(Box::new(n_static - 2)));
    Rc::new(
        n1.downcast_ref::&lt;i32&gt;().unwrap() +
        n2.downcast_ref::&lt;i32&gt;().unwrap())
    }
}
#}</code></pre></pre>
<ul>
<li><a href="http://cs242.stanford.edu/f18/assets/lectures/09-2-future-of-pl.pdf">source</a></li>
</ul>
<h1><a class="header" href="#lesson-three-pay-for-what-you-use-introduction-to-traits-and-enum-wrappers" id="lesson-three-pay-for-what-you-use-introduction-to-traits-and-enum-wrappers">Lesson Three: Pay for What You Use, Introduction to Traits and Enum Wrappers</a></h1>
<h2><a class="header" href="#objectives-3" id="objectives-3">Objectives</a></h2>
<ul>
<li>Understand types and what they implement - Traits </li>
</ul>
<h2><a class="header" href="#pay-for-what-you-use" id="pay-for-what-you-use">Pay for What you Use</a></h2>
<p>One of the philosophies of Rust is 'Pay only for what you use'.  Make no assumptions about what a type does - dive into the api doc.</p>
<p>The functionality that is on a type is from a <code>trait</code>, which from an OO perspective looks and feels like an interface.</p>
<p>In an OO language like .NET, the root object <code>Object</code> implements <code>Object.MemberwiseClone</code> and is accessible to all classes/objects.</p>
<p>Not so in Rust:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
  let name: &amp;'static str = &quot;Mycos&quot;;

    let mut name_borrower = String::default();
    let name: String = String::from(&quot;Mycos&quot;);

    name_borrower = name.to_owned();    &lt;--- Our String can do to_owned 
    name_borrower = name.clone();       &lt;--- AND clone() 

    //BUT, not all types can be .clone() 'd
    //Not all types implement the trait
    let v: &amp;[i32] = &amp;[1, 2];
    let vv: Vec&lt;i32&gt; = v.to_owned();
    let vv: Vec&lt;i32&gt; = v.clone()        &lt;---  Compile Error, the clone trait is not implemented
#}</code></pre></pre>
<h2><a class="header" href="#simple-trait-syntax" id="simple-trait-syntax">Simple Trait Syntax</a></h2>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Pay {
  fn pay() -&gt; i32; 
}

struct Company {
  name: String
}

impl Pay for Company {
  fn pay(&amp;self) -&gt; i32 {
    10
  }
}
#}</code></pre></pre>
<p>The 'Company' struct can then be invoked via its <code>trait</code> impl or implementation:</p>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
let company = Company { name: &quot;Mycos&quot; };
company.pay();
#}</code></pre></pre>
<h1><a class="header" href="#lesson-four-enums-and-type-basics" id="lesson-four-enums-and-type-basics">Lesson Four: Enums and Type Basics</a></h1>
<h2><a class="header" href="#objectives-4" id="objectives-4">Objectives</a></h2>
<ul>
<li>Understand working without NULL (you won't miss it) </li>
<li>Get familar with the standard library's enum wrappers <code>Option&lt;T&gt;</code> <code>Result&lt;Err, T&gt;</code> </li>
<li>Understand how to import a library/crate and reference it in a source file </li>
</ul>
<h2><a class="header" href="#null-stdoption-and-enum-wrappers" id="null-stdoption-and-enum-wrappers">NULL, std::option and Enum Wrappers</a></h2>
<p>There's no NULL type in Rust. </p>
<pre><code>if (x == null) ... is gone.
</code></pre>
<p>The <code>std::option::Option</code> type (no need to import) is used <em>very</em> often in Rust, typically to handle our NULL scenario - indicated the presence or absence of data. </p>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
pub enum Option&lt;T&gt; {
    /// No value
    None,
    /// Some value `T`
    Some(T),
}

#}</code></pre></pre>
<p>So, typically, if it is optional we define it as such:</p>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
struct Dieter {
    name: String,
    daily_calories: &lt;Option&lt;u8&gt;&gt;   // &lt;- tough diet, u8 is an unsigned 8 bit byte
}
#}</code></pre></pre>
<p>The dieter object may or may not have a defined amount of <code>daily_calories</code> and access to the value must be preceded by a check for its presence (Some or None).</p>
<p>Another built-in enum in the std library is the <code>Result&lt;T, E&gt;</code> which is used for returning values which can then be 'unwrapped' for errors OR propograted/thrown further up the call stack.</p>
<p>The definition, likewise, is simple:</p>
<pre><code>enum Result&lt;T, E&gt; {
   Ok(T),
   Err(E),
}
</code></pre>
<p>And the typical usage:</p>
<pre><pre class="playpen"><code class="language-rust">
use std::num::ParseIntError;

fn double_number(number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    match number_str.parse::&lt;i32&gt;() {
        Ok(n) =&gt; Ok(2 * n),
        Err(err) =&gt; Err(err),
    }
}

fn main() {
    match double_number(&quot;10&quot;) {
        Ok(n) =&gt; assert_eq!(n, 20),
        Err(err) =&gt; println!(&quot;Error: {:?}&quot;, err),
    }
}

</code></pre></pre>
<p>REF: match_101 and match_102 </p>
<h1><a class="header" href="#lesson-five-error-handling" id="lesson-five-error-handling">Lesson Five: Error Handling</a></h1>
<h2><a class="header" href="#objectives-5" id="objectives-5">Objectives</a></h2>
<ul>
<li>Understand the common error handling patterns </li>
<li>Review matching in the context of error handling</li>
</ul>
<h2><a class="header" href="#errors" id="errors">Errors:</a></h2>
<p>This is an excellent article on error handling in Rust here:  <a href="https://blog.burntsushi.net/rust-error-handling/">error handling</a></p>
<p>The Rust Book and Rust By Example are a bit thin in this category, so the article is highly recommended.</p>
<p>Frankly, handling errors in Rust requires more effort than programmers from dynmaically typed languages are accustomed to. </p>
<p>There are efforts like the <a href="https://github.com/rust-lang-nursery/failure">Failure</a> library which attempt to make it more ergonomic/friendly to use.</p>
<p>But, Here are the basics using only Rust's built-in types: </p>
<h2><a class="header" href="#error-propogation" id="error-propogation">Error Propogation</a></h2>
<p>Like <code>Options</code>, <code>Results</code> can use <code>.unwrap()</code>  As of Rust 2018, a nicer way to handle errors is to propogate via the <code>?</code> operator.</p>
<p>It's analogous to throwing an Exception in an OO language. If it unwraps to an <code>Err</code>, throw it up the chain. </p>
<h2><a class="header" href="#the-flow-of-options-and-results" id="the-flow-of-options-and-results">The Flow of Options and Results</a></h2>
<p><code>Result&lt;T, E&gt;</code>, for OO programmers, <em>looks like</em> like a 'parent' return type.  OO programmers can use parent types to easily return the more specific errors in sub-class instances.  <code>Result&lt;T, E&gt;</code> doesn't do this.</p>
<ol>
<li>Exactly, like <code>Option&lt;T&gt;</code>, Results are unwrapped, typically with a <code>match</code> statement.</li>
<li>But, the reasoning process for Results vs. Options is not the not the same and introduces one additional step </li>
</ol>
<p>With Options:</p>
<pre><code>                    Option&lt;T&gt;                                                       
                       |                                                                  
          Some         or               None                                  
            |                             | 
We know our T and get to work       Missing, handle accordingly 
</code></pre>
<p>But, with Results:</p>
<pre><code>                    Result&lt;T, E&gt;                                                       
                       |                                                                  
           Ok          or                Err                                  
            |                             | 
We know our T and get to work       We *might* have an Error (a trait)
                                          |
                                    We find the specific error for return type size
                                          |
                                    We return Result handling the content behind Err
                                    with full knowledge of its underlying type
</code></pre>
<p>In OO programming we have the luxury of handling errors without knowing all the details, because if an error is thrown or I throw an error, we at least know it derives from an Error (typically an Exception class).</p>
<p>In Rust, however, we <em>must</em> know the exact content of the Result's Err in order to handle it completely.  In fact the <code>E</code> in <code>Result&lt;T, E&gt;</code> needn't be an <code>Error</code> (deriving from the Error trait) at all (a String here for illustrative purpose):</p>
<pre><pre class="playpen"><code class="language-rust">
fn main() -&gt; Result&lt;(), Box&lt;String&gt;&gt; {
    let function_result = is_positive(-2);
    println!(&quot;{:?}&quot;, function_result?);
    Ok(())
}

fn is_positive(number: i64) -&gt; Result&lt;(), String&gt; {
    if number &lt; 0 {
        return Err(&quot;emergency failure&quot;.to_string());
    }
    Ok(())
}
</code></pre></pre>
<p>An additional layer of digging is often required because, aside from the above, types including
<code>Result&lt;T, E&gt;</code> are frequently aliased, e.g.: </p>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
type AliasedResult&lt;T&gt; = Result&lt;T, String&gt;;
#}</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">
fn main() -&gt; AliasedResult&lt;()&gt; {
    let function_result = is_positive(-2);
    println!(&quot;{:?}&quot;, function_result?);
    Ok(())
}


type AliasedResult&lt;T&gt; = Result&lt;T, String&gt;;

fn is_positive(number: i64) -&gt; AliasedResult&lt;()&gt; {
    if number &lt; 0 {
        return Err(&quot;emergency failure&quot;.to_string());
    }
    Ok(())
}

</code></pre></pre>
<h2><a class="header" href="#using-dyn-error-to-wrap-errors" id="using-dyn-error-to-wrap-errors">Using dyn Error to wrap errors</a></h2>
<p>The next challenge in Rust error handling is dealing with errors thrown by <em>other</em> libraries.  Althoug the specifics of the underlying error are unknown, if we know that the error is an Error of std::error::Error type, we can still <code>Box&lt;dyn Error&gt;</code> the error as shown below:</p>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
pub fn build_config(args: Vec&lt;String&gt;) -&gt; Result&lt;SuiteConfig, Box&lt;dyn std::error::Error&gt;&gt; {

//.. ommitted code

            Err(e) =&gt; {
                println!(&quot;Error opening the file: {:?}&quot;, e.description());
                return Err(Box::new(e));
            }
}
#}</code></pre></pre>
<h2><a class="header" href="#summary" id="summary">Summary:</a></h2>
<ol>
<li>Using the <code>?</code> makes errors easier to read and makes higher-level code flow more sensibly.</li>
<li>If you are using a Result (your own or from a function you invoke), first determine the type unwrapped by Err.</li>
<li>Make no assumptions that the Err wraps a type implementing the Error trait.</li>
<li>If you are handling other libraries' errors, you can use <code>Box</code> to wrap the libraries errors. </li>
</ol>
<h1><a class="header" href="#lesson-six-almighty-iterators" id="lesson-six-almighty-iterators">Lesson Six: Almighty Iterators</a></h1>
<h2><a class="header" href="#objectives-6" id="objectives-6">Objectives</a></h2>
<ul>
<li>Look at some looping, enumerate constructs </li>
<li>Understand when and how to use an iterator</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
fn main() {


}


fn simple_range() {

	for i in 0..30 {
		println!(&quot;{}&quot;, i);
	}
}


TODO: Enumerate Sample

</code></pre></pre>
<h3><a class="header" href="#homework-notes" id="homework-notes">Homework Notes</a></h3>
<h1><a class="header" href="#lesson-seven-import-syntax-and-project-structure" id="lesson-seven-import-syntax-and-project-structure">Lesson Seven: Import Syntax and Project Structure</a></h1>
<h2><a class="header" href="#objectives-7" id="objectives-7">Objectives</a></h2>
<p>We've covered quite a few of the fundamentals. Housekeeping lessons are quick visit on a series of topics.</p>
<h2><a class="header" href="#importuse-syntax" id="importuse-syntax">Import/Use syntax</a></h2>
<p>Rust 2018 (a major release from, surprise, 2018), does not require 'extern crate' in most cases. If the dependency is 
listed in the Cargo.toml, only 'use crate_name' is needed.  Older sample code may indicate otherwise.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
 extern crate colored; // not needed in Rust 2018
    
use colored::*;
#}</code></pre></pre>
<h2><a class="header" href="#syntax-variations-for-crates-and-modules" id="syntax-variations-for-crates-and-modules">Syntax variations for crates and modules</a></h2>
<p>For  somecrate::somemodule::somesubmodule::somefunction</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use somecrate::*;
#}</code></pre></pre>
<p>Syntax will be:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
somemodule::somesubmodule::somefunction()
#}</code></pre></pre>
<p>The invocation starts where the the use statement ends.</p>
<p>We can also: </p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use somecrate::{SomeStruct, somefunction};
#}</code></pre></pre>
<p>Or:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use somecrate::{SomeStruct, somefunction};
#}</code></pre></pre>
<p>Or:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use somecrate::somesubmodule::{SomeStruct, somefunction};
#}</code></pre></pre>
<h2><a class="header" href="#project-structure" id="project-structure">Project Structure</a></h2>
<p>There is a 'top level' to any library or binary (executable) and it is named in the cargo.toml</p>
<p>The 'top level' is also responsible for exporting public members (using the <code>pub</code> keyword)</p>
<p>Typical Project Structure:</p>
<pre><code>  main.rs    or   lib.rs               
              |      
</code></pre>
<p>subdirectory_01  subdirectory_02<br />
|              |<br />
mod.rs         mod.rs</p>
<ul>
<li>
<p>You can use <code>mod</code> to create modules anywhere</p>
</li>
<li>
<p>The <em>parent</em> controls the visibility of the children who are public by 're-exposing' them, e.g.:
<code>pub mychildmod</code></p>
</li>
<li>
<p>This likewise applies to the top-level crate which selectively makes other crates and functions public</p>
</li>
</ul>
<h3><a class="header" href="#importing-macros" id="importing-macros">Importing Macros</a></h3>
<p>This needs to happen at the top level of the crate</p>
<pre><code>#[macro_use]
extern crate criterion;
</code></pre>
<h3><a class="header" href="#tuples-multiple-types---one-data-structure" id="tuples-multiple-types---one-data-structure">Tuples: Multiple Types - One Data Structure</a></h3>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let (a, b, c, d) = (&quot;I'm&quot;.to_string(), &quot;a&quot;.to_string(), &quot;tuple&quot;.to_string(), 32);
#}</code></pre></pre>
<h3><a class="header" href="#vectors---a-common-rust-datastructure" id="vectors---a-common-rust-datastructure">Vectors - A Common Rust Datastructure</a></h3>
<p>For vectors, we get some 'standard' operations: push, pop, index (e.g. our_vector[0])</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut collected_iterator: Vec&lt;i32&gt; = (0..10).collect();
println!(&quot;Collected (0..10) into: {:?}&quot;, collected_iterator);

// The `vec!` macro can be used to initialize a vector
let mut xs = vec![1i32, 2, 3];
println!(&quot;Initial vector: {:?}&quot;, xs);

// Thanks to `iter_mut`, mutable `Vector`s can also be iterated
// over in a way that allows modifying each value, note the dereference operator
for x in xs.iter_mut() {
    *x *= 3;
    println!(&quot;Updated vector: {:?}&quot;, xs);
}
#}</code></pre></pre>
<h3><a class="header" href="#cargotoml" id="cargotoml">Cargo.toml</a></h3>
<p>The <a href="https://doc.rust-lang.org/cargo/reference/manifest.html">Cargo.toml manifest</a> is extremely powerful and flexible.</p>
<p>At a high-level, you can:</p>
<ul>
<li>Split 'features' within your crate to make optional dependencies</li>
<li>Split the workspace for multiple crates joined in a single toml.lock</li>
<li>Override dependencies</li>
<li>Use files or git repositories as the source of dependencies</li>
<li>Support multiple libraries or binaries</li>
</ul>
<p>one example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
[dependencies]
rand = { git = &quot;https://github.com/rust-lang-nursery/rand.git&quot; }
#}</code></pre></pre>
<h1><a class="header" href="#lesson-eight-closures-and-lifetimes-preview" id="lesson-eight-closures-and-lifetimes-preview">Lesson Eight: Closures and Lifetimes Preview</a></h1>
<h2><a class="header" href="#objectives-8" id="objectives-8">Objectives</a></h2>
<ul>
<li>Understand the basics of closures</li>
<li>Preview lifetime annotations </li>
</ul>
<h3><a class="header" href="#closure-essentials" id="closure-essentials">Closure Essentials</a></h3>
<ul>
<li>Closures look <em>a lot</em> like functions</li>
</ul>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
fn  plus_one_v1   (x: i32) -&gt; i32 { x + 1 };
let plus_one_v2 = |x: i32| -&gt; i32 { x + 1 };
let plus_one_v3 = |x: i32|          x + 1  ;
#}</code></pre></pre>
<ul>
<li>Closures can be parameters to functions, return values from functions, 'in-line' as lambda expressions,
and assigned to a variable and 'invoked' later.</li>
</ul>
<p>They are <code>lazy</code> initialized. </p>
<ul>
<li>Closures that mutate values must be annotated as <code>mut</code> </li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
  let mut a_closure = |t| t = t + 1; 
#}</code></pre></pre>
<ul>
<li>The <code>move</code> keyword makes the closure take ownership of the referenced values.</li>
</ul>
<p>Note the error generated by the following code:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = vec![1, 2, 3];
    let equal_to_x = move |z| z == x;

    println!(&quot;can't use x here: {:?}&quot;, x);

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}
</code></pre></pre>
<ul>
<li>A closure with an explicit type annotation</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let haystack = vec![1, 2, 3];

    let contains = |needle: &amp;i32| haystack.contains(needle);

    println!(&quot;{}&quot;, contains(&amp;1));
#}</code></pre></pre>
<p>The closure above is called <em>exactly</em> as a method/function is called.</p>
<p>The <code>iter()</code> trait exposes some excellent functions detailed <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#provided-methods">here</a>
and summarized with <em>impressive fonts</em> <a href="https://danielkeep.github.io/itercheat_baked.html">here</a></p>
<h3><a class="header" href="#introduction-to-lifetimes" id="introduction-to-lifetimes">Introduction to Lifetimes</a></h3>
<p>We know Rust is good at throwing away things.  Out of scope, out of memory.  That, however, introduces a problem.  We don't always want to throw away associated values.  We want them to <em>live</em> longer.  The compiler tracks the 'lifetime' of values (all of them actually), but when it sees code that uses values beyond the obvious scope (lifetime), it requies an explicit annotation of the lifetime.</p>
<p>For now - just read <code>'a</code> as 'lifetime annotation' and note (obviously?), that type parameters (like 'a) have to be used. </p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Foo&lt;'a&gt; {
    x: &amp;'a i32,
}
#}</code></pre></pre>
<h3><a class="header" href="#exercise" id="exercise">Exercise</a></h3>
<p>This exercise touches on a few topics: Vectors, iterators, and closures.</p>
<p>The <code>iter</code> trait has many functions like <code>map</code> and <code>filter</code> that take closures as arguments. 
They do this by implementing FnMut, which is one way, together with <code>FnOnce</code> and ```Fn`` to control how closures capture their surrounding values.</p>
<p>Practically, this let's us pipe the ```iter`` results to other functions in a nice, functional style.</p>
<h1><a class="header" href="#lesson-nine-lifetime-annotations" id="lesson-nine-lifetime-annotations">Lesson Nine: Lifetime Annotations</a></h1>
<h2><a class="header" href="#objectives-9" id="objectives-9">Objectives</a></h2>
<ul>
<li>Understand the basics of Lifetime Annotations</li>
</ul>
<h2><a class="header" href="#the-problem" id="the-problem">The problem</a></h2>
<p>Java, .NET, Go and others use garbage collection to manage the 'generations' of object references and release them.</p>
<p>Rust does not use a garbage collection process. Consequently, memory utilization is extremely efficient.  One of the trade-off's, however, is that we sometimes need to explictly provide instructions regarding how long objects are intended to live.</p>
<p>Look at the code below.  We pass our &amp;str's to a function, that does an evaluation, and then returns one of the str's
After the function returns, the parameter &amp;str's, go out of scope.</p>
<p>The borrow-checker efficiently wants to drop the references at the end of the scoped block, <em>but</em> the returned value is referencing one of them.</p>
<p>The compiler needs explicit instructions.  This is done with a special 'marker' called the 'lifetime annotation.'</p>
<pre><pre class="playpen"><code class="language-rust">
fn main() {

    let target: &amp;str;

    //Narrow our scope
    {
        let string1 = &quot;abcd&quot;;
        let string2 = &quot;xyzwkrp&quot;;

        target = longest(string1, string2);

        println!(&quot;The longest string is {}&quot;, target);
    } // &lt;- goodbye string1, string2... I think...

    println!(&quot;The longest string is {}&quot;, target);
}

fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {  // &lt;- without 'a this fails.
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}

</code></pre></pre>
<p>Actually, Rust requires lifetimes on all parameter and return value references, but it became a pain to type:</p>
<pre><code>fn longest(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str ... 
</code></pre>
<p>So, 'they' dropped the cases where it was obvious and gave the heruistics a French name, 'lifetime elision rules' so no one would ask anymore questions. </p>
<h2><a class="header" href="#exercise-1" id="exercise-1">Exercise</a></h2>
<p>Create a binary tree datastructure.</p>
<p>Each node may have a parent, a node to the left, and a node to the right.</p>
<p>Add one function/method that allows insertion of a node.</p>
<p>You will almost certainly need to use lifetime annotations and possibly Box<T>.  If you cannot complete the exercise, have no fear and keep moving forward.</p>
<h4><a class="header" href="#related-fun" id="related-fun">Related Fun:</a></h4>
<ul>
<li>A pretty node-free Graph implementation
<a href="https://github.com/EbTech/rust-algorithms/blob/master/src/graph/mod.rs">Contest Algorithms, Graph:</a></li>
</ul>
<h1><a class="header" href="#lesson-nine-unit-testing" id="lesson-nine-unit-testing">Lesson Nine: Unit Testing</a></h1>
<h2><a class="header" href="#objectives-10" id="objectives-10">Objectives</a></h2>
<ul>
<li>Unit Testing</li>
<li>Tests directory, benches, and examples </li>
</ul>
<h2><a class="header" href="#testing" id="testing">Testing</a></h2>
<p>By convention, integration tests are added in the /tests directory.  They import the crate(s) they are testing.</p>
<p>Standard unit tests are normally added in the source files, sometimes inside a separate <code>mod tests</code></p>
<p>The #[cfg(test)] macro attribute gives some control over how they are run and exluded from releases.</p>
<h3><a class="header" href="#unit-tests-are-normally-created-with" id="unit-tests-are-normally-created-with">Unit Tests are normally created with:</a></h3>
<p><code>#[test]</code></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
assert!(expression)
assert_eq!(left, right)
assert_ne!(left, right)
#}</code></pre></pre>
<p>And run with <code>cargo test</code></p>
<h3><a class="header" href="#running-unit-tests-with-output" id="running-unit-tests-with-output">Running Unit Tests with Output</a></h3>
<p>If you use output in unit tests, like println!(), the output is hidden unless you add --no-capture</p>
<pre><code>cargo test -- --nocapture
</code></pre>
<h2><a class="header" href="#examples" id="examples">Examples</a></h2>
<p>It's common in rust code, especially on github, to put examples in an <code>/examples</code> directory.  Cargo/Rust supports that
convention:</p>
<p><code>cargo run --example [example_name]</code></p>
<h3><a class="header" href="#test" id="test">TEST!!!</a></h3>
<p>This is a refresher on borrowing and mutablity.</p>
<ul>
<li>In the /demos/test_lesson_10 you will find a set of functions calls commented out.</li>
<li>Review the functions and ask yourself, &quot;does this compile?&quot;</li>
</ul>
<h3><a class="header" href="#homework" id="homework">Homework</a></h3>
<p>This is homework is a short one:
Create a simple function, and write a unit test for that function</p>
<h1><a class="header" href="#lesson-eleven-boxt-and-optiont-resultt-err-again" id="lesson-eleven-boxt-and-optiont-resultt-err-again">Lesson Eleven: Box<T> and Option<T> Result&lt;T, Err&gt; (Again!)</a></h1>
<h2><a class="header" href="#objectives-11" id="objectives-11">Objectives</a></h2>
<ul>
<li>Drive home Option and Result Usage </li>
<li>How to use dyn and boxing </li>
</ul>
<h2><a class="header" href="#homework-1" id="homework-1">Homework:</a></h2>
<p>Catchup day 2.  No new assignment.</p>
<h1><a class="header" href="#lesson-twelve--trait-bounds" id="lesson-twelve--trait-bounds">Lesson Twelve:  Trait Bounds</a></h1>
<h2><a class="header" href="#objectives-12" id="objectives-12">Objectives</a></h2>
<ul>
<li>Trait Bounds Basics</li>
</ul>
<hr />
<h3><a class="header" href="#trait-bounds" id="trait-bounds">Trait Bounds</a></h3>
<p>As an OO programmer, you are likely already familiar with generics. </p>
<p>In Rust there are similarities and differences.</p>
<p>First, it's important to get clear on some terminology.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn apply&lt;F, T&gt;(f: F, t: T)
where
    F: FnOnce(),
{
    f();

    do_something(t);
}

fn do_something&lt;T&gt;(t: T) {
    let z: Box&lt;T&gt; = Box::new(t);
}
#}</code></pre></pre>
<p>In the code above, </p>
<p><code>fn apply&lt;F, T&gt;(f: F, t: T) where F: FnOnce()</code></p>
<p>is the entire type signature.</p>
<p><code>&lt;F, T&gt;</code> specifies two type parameters.  We know nothing about them, other than they are types.</p>
<p><code>where F: FnOnce()</code> is a trait bound.  It's a constrait that requires any generic type used in the function to implement the FnOnce() trait.</p>
<p>Additionally:</p>
<p>You can pass a trait <code>impl</code> as a parameter:</p>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
pub fn notify(item: impl Summary) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
#}</code></pre></pre>
<p>But, what about traits as <em>generics</em>?  Perhaps:</p>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
pub fn notify&lt;T&gt;(item: T) {
    println!(&quot;Breaking news! {}&quot;, item.summarize()); //&lt;- what's a summarize?
}
#}</code></pre></pre>
<p>In the code above, the Rust toolchain has <em>no</em> information on the types' functions, etc. and will not compile. It needs more information. </p>
<p>To solve the issue in the context of generics, Rust uses <code>trait bounds</code> </p>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
pub fn notify&lt;T: Summary&gt;(item: T) {
    ...
}
#}</code></pre></pre>
<p>which is the same as:</p>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
pub fn notify(item: impl Summary) {
}
#}</code></pre></pre>
<p>For better clarity, this can also be written as:</p>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
pub fn notify&lt;T&gt;(item: T) 
where T: Summary {
    ...
}
#}</code></pre></pre>
<p>And, applied across multiple traits with:</p>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
pub fn notify&lt;T: Summary + Display&gt;(item: T) 
where T: Summary + Display {
    ...
}
#}</code></pre></pre>
<p>Read the above, &quot;the notify function is bound by the behavior of the Summary and Display traits.&quot;</p>
<h3><a class="header" href="#key-points-on-traits" id="key-points-on-traits">Key Points on Traits</a></h3>
<ul>
<li>Trait objects are dynamically sized and are behind a reference of some type.</li>
<li>Consequently, and unlike generics and plain functions/methods, they are dynamically dispatched at runtime. </li>
</ul>
<h3><a class="header" href="#function-overloading-ish" id="function-overloading-ish">Function Overloading-ish</a></h3>
<p>As an OO programmer, note that no-inhertiance != no-indirection.  The <code>SimpleTaxer</code> resolves the appropriate calculation method.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let usa = USA {
        tax_calculator: Box::new(SimpleTaxer {}),
    };

    let thailand = Thailand {
        tax_calculator: Box::new(SimpleTaxer {}),
    };

    println!(
        &quot;USA tax: {}&quot;,
        usa.tax_calculator.compound_tax(333.0, 2.3, 3.3)
    );
    println!(
        &quot;Thailand tax: {}&quot;,
        thailand.tax_calculator.calculate_tax(333.0, 2.3)
    );
}

trait SimpleTax {
    fn calculate_tax(&amp;self, amount: f32, rate: f32) -&gt; f32;
}

trait CompoundTax: SimpleTax {
    fn compound_tax(&amp;self, amount: f32, base_rate: f32, rate: f32) -&gt; f32;
}

struct USA {
    pub tax_calculator: Box&lt;dyn CompoundTax&gt;,
}

struct Thailand {
    pub tax_calculator: Box&lt;dyn SimpleTax&gt;,
}

struct SimpleTaxer {}

impl SimpleTax for SimpleTaxer {
    fn calculate_tax(&amp;self, amount: f32, rate: f32) -&gt; f32 {
        amount * rate
    }
}
impl CompoundTax for SimpleTaxer {
    fn compound_tax(&amp;self, amount: f32, base_rate: f32, compound_rate: f32) -&gt; f32 {
        let base_tax = &amp;self.calculate_tax(amount, base_rate);
        base_tax + amount * compound_rate
    }
}
</code></pre></pre>
<ul>
<li>As a side note, if the content here, the API doc, and 'The Book' still leave you unclear on a topic,
try <a href="https://doc.rust-lang.org/stable/reference/">The Reference</a> Some of the explanations are excellent.  Remarkably
similar to some of the content here.  ;)</li>
</ul>
<h3><a class="header" href="#exercise-2" id="exercise-2">Exercise</a></h3>
<p>In the below below, using a trait, create a converter between Kilos, Pounds, and Stone</p>
<pre><pre class="playpen"><code class="language-rust">enum UomWeight { 
    Kilos,
    Pounds,
    Stone
}  //UOM -&gt; Unit of Measure

impl UomWeight {
    fn value(&amp;self) -&gt; f32 {
        match *self {
            UomWeight::Kilos =&gt; 1.0,
            UomWeight::Pounds =&gt; 2.20462,
            UomWeight::Stone =&gt; 0.157473,
        }
    }
    fn unit(&amp;self) -&gt; String {
        match *self {
            UomWeight::Kilos =&gt; String::from(&quot;Kilogram&quot;),
            UomWeight::Pounds =&gt; String::from(&quot;Pound&quot;),
            UomWeight::Stone =&gt; String::from(&quot;Stone&quot;),
        }
    }
}


// 2.20462 =&gt; Kilos to Pounds
// 0.157473 =&gt; Kilos to Stone

struct InventoryItem {
    mass: f32,
    pub convertor: Box&lt;dyn Weightable&gt;
} //...more code

trait Weightable {
    fn weight(&amp;self) -&gt; f32;
}

impl Weightable for InventoryItem {
    fn weight(&amp;self) -&gt; f32 {
        self.mass * self.convertor.weight()
    }
}

impl Weightable for UomWeight {
    fn weight(&amp;self) -&gt; f32 {
        self.value()
    }
}

fn main() {
    let item1 = InventoryItem {
        mass: 10.0,
        convertor: Box::new(UomWeight::Kilos),
    };

    println!(
        &quot;Weight of Mass {} in {} = {}&quot;,
        item1.mass,
        UomWeight::Kilos.unit(),
        item1.weight()
    );

    let item2 = InventoryItem {
        mass: 10.0,
        convertor: Box::new(UomWeight::Pounds),
    };

    println!(
        &quot;Weight of Mass {} in {} = {}&quot;,
        item2.mass,
        UomWeight::Pounds.unit(),
        item2.weight()
    );

    let item3 = InventoryItem {
        mass: 10.0,
        convertor: Box::new(UomWeight::Stone),
    };

    println!(
        &quot;Weight of Mass {} in {} = {}&quot;,
        item3.mass,
        UomWeight::Stone.unit(),
        item3.weight()
    );
    //1: create an inventory item
    //3: output the converted value 
    // Use a trait
}
</code></pre></pre>
<h1><a class="header" href="#lesson-thirteen-constructors-patterns" id="lesson-thirteen-constructors-patterns">Lesson Thirteen: Constructors Patterns</a></h1>
<p>OO programmers often think of Objects as the launching point of code, particularly, 'newing up' an object.</p>
<p>Although powerful, this approach can lead to monolithic 'engine' classes and that become black-boxes when the API or surface is exposed to other developers (though it needn't - we are aware). </p>
<p>Rust programmers often think first in terms of shared behavior or functionality, so it's at least worth asking, &quot;Is this shared functionality and is it best abstracted into a trait?&quot;</p>
<p>Here we'll peek at some of the patterns (mostly from std::lib) used to construct things.</p>
<h2><a class="header" href="#objectives-13" id="objectives-13">Objectives</a></h2>
<ul>
<li>Understand Constructor/Initalization Forms </li>
</ul>
<h3><a class="header" href="#constructor-patterns-comments-in-code" id="constructor-patterns-comments-in-code">Constructor Patterns (Comments in code)</a></h3>
<p>Notes: </p>
<pre><pre class="playpen"><code class="language-rust">//PATTERN ONE: static, default impl 
//This is the default impl for the struct 
//There's nothing special about `new` as function name here.
//`Self` or `&amp;self` is never used. 
#[derive(Debug, PartialEq)]
struct Counter {
    count: u32,
}

impl Counter {
    fn new() -&gt; Counter {
        Counter { count: 0 }
    }
}

//PATTERN TWO: static, Self
//Exactly the same. Basic struct, but with 'Self' as return type
struct SelfishCounter {
    count: u32,
}

impl SelfishCounter {
    fn new() -&gt; Self {
        SelfishCounter { count: 0 }
    }
}

//PATTERN THREE: Self -&gt; Self
//Exactly the same as above, but `Self` is used for the 
//return value and return type, rather than the struct name 
struct ABitSelfishCounter {
    count: u32,
}

//Using the 'Self' constructor
impl ABitSelfishCounter {
    fn new() -&gt; Self {
        Self { count: 0 }
    }
}

fn main() {
    //PATTERN ONE
    let counter = Counter::new();
    assert_eq!(counter.count, 0);

    //PATTERN TWO 
    let selfish_counter = SelfishCounter::new();
    assert_eq!(selfish_counter.count, 0);

    //PATTERN THREE 
    let a_bit_selfish_counter = ABitSelfishCounter::new();
    assert_eq!(a_bit_selfish_counter.count, 0);

    #println!(&quot;If we ran to here without an error in the asserts, it was successful.&quot;);

}
</code></pre></pre>
<h3><a class="header" href="#builder-pattern" id="builder-pattern">Builder Pattern</a></h3>
<p>https://docs.rs/derive_builder/0.7.2/derive_builder/</p>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
 let person = PersonBuilder::default().name(&quot;krishnab&quot;).build();
#}</code></pre></pre>
<h3><a class="header" href="#tuple-struct" id="tuple-struct">Tuple Struct</a></h3>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
//PATTERN FOUR: Tuple Struct
pub struct Fingerprint(u64, u64);

impl Fingerprint {
    pub const ZERO: Fingerprint = Fingerprint(0, 0);
    pub fn hi() {} //... more code
}


#}</code></pre></pre>
<p>Usage:</p>
<pre><code>let zero_zero_tuple_struct = Fingerprint::ZERO;
</code></pre>
<p>or, equivilantly:</p>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
let zero_zero_tuple_struct = Fingerprint(0, 0);
#}</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">
#[derive(Debug, PartialEq)]
pub struct Fingerprint(u64, u64);

impl Fingerprint {
    pub const ZERO: Fingerprint = Fingerprint(0, 0);
    pub fn hi() {} //... more code
}

fn main() {
    let fp = Fingerprint(7, 7);
    assert_eq!(fp.0, 7);

    let zeroed = Fingerprint::ZERO;
    assert_ne!(zeroed.0, fp.0);

    let zeroed_two = Fingerprint(0, 0);
    assert_eq!(zeroed, zeroed_two);

    #println!(&quot;If we ran to here without an error in the asserts, it was successful.&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#lesson-fourteen-iterator-patterns" id="lesson-fourteen-iterator-patterns">Lesson Fourteen: Iterator Patterns</a></h1>
<h2><a class="header" href="#objectives-14" id="objectives-14">Objectives</a></h2>
<ul>
<li>Understand Some of the main patterns used for iteration </li>
</ul>
<pre><pre class="playpen"><code class="language-rust">///Working with iterators
///
/// An iterator has an associated type and a next method
///
///trait Iterator {
///  type Item;
///  fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
///}
///
fn main() {
    standard_iteration();
    iteration_with_enumerate();
    iterate_with_into_iter();
    iter_little_things();
}

fn standard_iteration() {
    for i in 0..3 {
        println!(&quot;Standard Iterator: {:?}&quot;, i);
    }
}

///enumerate() takes an iterator and returns the value and index of the iteration
///increment the index
fn iteration_with_enumerate() {
    for (mut i, j) in (5..8).enumerate() {
        i += 1;
        println!(
            &quot;Enumerate with increment on value - value {:?}, loop iteration: {:?}&quot;,
            i, j
        );
    }
}

///into_iter iterates the value instead of the reference
fn iterate_with_into_iter() {
    let q = vec![&quot;Jim&quot;, &quot;John&quot;, &quot;Mary&quot;, &quot;Kim&quot;, &quot;Marcus&quot;];

    //Standard iter() iterates over the reference &amp;T
    for name in q.iter() {
        println!(&quot;Name is: {:?}&quot;, *name); // &lt;- Dereferencing (*) here, is equivilant
                                          //    to .into_iter() below
    }

    //into_iter() iterates over just T
    //This code will error if
    for name in q.into_iter() {
        // &lt;- into_iter here is equivilant to * above
        println!(&quot;Name is: {:?}&quot;, name);
    }
}

//A good example of iterators in an idomatic rust style from tools::tidy
fn iter_little_things() {
    let semantic_version_number = &quot;1.2.3&quot;;

    //1 - Take the elements from the split method and return a new iterator
    //2 - Take that iterator and use .map to create another iterator
    //3 - Create a closure that takes an iterator and invokes the next method
    //4 - The iterator holds our state and when the function of the closure exceeds
    //    the bounds of the mapped string, an error is returned

    let mut iterator = semantic_version_number
        .split('.')
        .map(|part| part.parse::&lt;u32&gt;());

    let mut part = || {
        match iterator.next() {
            None =&gt; println!(&quot;Error in referencing semantic version number.  Be sure the parts are split with '.', are integer types, and that there are no more than 3.&quot;),
            Some(e) =&gt; println!(&quot;{:?}&quot;, e.unwrap()), 
        };
    };

    part();
    part();
    part();
    part(); // &lt;- greater than 3 bombs
}

</code></pre></pre>
<p>enum Permissions {
Sys(u8),
Org(u8),
Group(u8),
User(u8),
}</p>
<p>impl Permissions {
pub fn new() -&gt; Self {
PMask {
sys: 0b00000000,
org: 0b00000000,
group: 0b00000000,
user: 0b00000000,
}
}
}</p>
<pre><code>fn apply(&amp;self) -&gt; impl Iterator&lt;Item = u8&gt; {
    let s = iter::once(self.sys);
    let o = iter::once(self.org);
    let g = iter::once(self.group);
    let u = iter::once(self.user);
    s.chain(o).chain(g).chain(u)
}
</code></pre>
<p>}</p>
<h1><a class="header" href="#lesson-fifteen-copy-clone-drop-and-sized-traits-problem-preview" id="lesson-fifteen-copy-clone-drop-and-sized-traits-problem-preview">Lesson Fifteen: Copy, Clone, Drop and Sized Traits, Problem Preview</a></h1>
<h2><a class="header" href="#objectives-15" id="objectives-15">Objectives</a></h2>
<ul>
<li>Understand The Copy, Clone, Drop and Sized Traits </li>
</ul>
<h3><a class="header" href="#lesson-12-assignment-reviewdiscussion" id="lesson-12-assignment-reviewdiscussion">Lesson 12 Assignment Review/Discussion</a></h3>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=183d5e20941f9d96071260c036c12e10">One Solution</a></p>
<h2><a class="header" href="#three-special-traits-copy-clone-size" id="three-special-traits-copy-clone-size">Three Special Traits: Copy, Clone, Size</a></h2>
<p>The <code>Copy</code> trait uses mem::copy underneath and is implicit (you can use = operator),  <code>Clone</code> is explicit (.clone()) </p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Copy, Clone)]
struct Motocy;
#}</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Motorcy;

impl Copy for Motorcy { }

impl Clone for Motorcy {
    fn clone(&amp;self) -&gt; Motorcy {
        *self
    }
}
#}</code></pre></pre>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=291d8a0f3d018fd84909a45475b1af57">Copy/Clone Playground</a></p>
<h2><a class="header" href="#three-special-traits-copy-clone-size-1" id="three-special-traits-copy-clone-size-1">Three Special Traits: Copy, Clone, Size</a></h2>
<!-- 
https://stackoverflow.com/questions/30938499/why-is-the-sized-bound-necessary-in-this-trait
let x: Display = ...;
In this case, the compiler does not know which type is actually used here, it is erased, therefore it does not know the size of values of these types. The above line is not valid - you can't make a local variable without knowing its size (to allocate enough bytes on the stack), and you can't pass the value of an unsized type into a function as an argument or return it from one.

Unsized types can be used through a pointer, however, which can carry additional information - the length of available data for slices (&[u32]) or a pointer to a virtual table (Box<SomeTrait>). Because pointers always have a fixed and known size, they can be stored in local variables and be passed into or returned from functions.

Given any concrete type you can always say whether it is sized or unsized. With generics, however, a question arises - is some type parameter sized or not?

fn generic_fn<T>(x: T) -> T { ... }
If T is unsized, then such a function definition is incorrect, as you can't pass unsized values around directly. If it is sized, then all is OK.

In Rust all generic type parameters are sized by default everywhere - in functions, in structs and in traits. They have an implicit Sized bound; Sized is a trait for marking sized types:

fn generic_fn<T: Sized>(x: T) -> T { ... }
This is because in the overwhelming number of times you want your generic parameters to be sized. Sometimes, however, you'd want to opt-out of sizedness, and this can be done with ?Sized bound:

fn generic_fn<T: ?Sized>(x: &T) -> u32 { ... } -->
<h3><a class="header" href="#problem-preview-box-ref-refcell" id="problem-preview-box-ref-refcell">Problem Preview (Box, Ref, RefCell)</a></h3>
<p>The exercise/assigment is to review the problem presented in this code.</p>
<pre><pre class="playpen"><code class="language-rust">#[allow(dead_code)]
use std::cell::{ Ref, RefCell};
///
/// We have a hypothetical neighborhood that looks like this:
///
///                   HOUSE_A   HOUSE_B    HOUSE_C     HOUS
///                   ---------------------------------   E
///                            SOI 13                  |  _
///                   ---------------------------|     |  D
///                                              |     |  
///                                              |  S  |  
///                                              |  O  |
///                                              |  I  |
///                                              |     |  H
///                                              |  1  |  O
///                                              |  2  |  U
///                                              |     |  S
///                                              |     |  E
///                                              |     |  _
///                                              |     |  E
///
///
/// Noteably, HOUSE_D, is on both Soi 12 and 13
///
/// If street contains N houses, we have a problem with this simple implementation.
///
/// We have 3 first solutions to consider:
/// 1: Box&lt;T&gt;: Heap allocate and wrap with a stack reference
/// 2: Rc&lt;T&gt;: Wrap with a counted, shareable immutable reference, compile-time checked, for single threaded scenarios
/// 3: RcCell&lt;T&gt; Wrap with a counted, shareable mutable reference, runtime checked

fn main() {
    //setup a house
    let house_a = House::new().setup_house(1, 2);
    let house_e = House::new().setup_house(3, 2);
    let house_d = House::new().setup_house(2, 1);

    //Create the streets
    let mut street_0 = Street { houses: Vec::new() };
    let mut street_1 = Street { houses: Vec::new() };

    street_1.houses.push(house_a.borrow());
    street_0.houses.push(house_e.borrow());

    //house_d is on both streets
    street_1.houses.push(house_d.borrow());
    street_0.houses.push(house_d.borrow());

    println!(&quot;Street 0:\t\t&quot;);
    for h in street_0.houses {
        println!(&quot;\tHouse Size\t:{:?}&quot;, &amp;h.get_house_size());
        println!(&quot;\tHouse Plan\t:{:?}&quot;, &amp;h.details());
    }
    println!(&quot;Street 1:\t\t&quot;);
    for h in street_1.houses {
        println!(&quot;\tHouse Size\t:{:?}&quot;, &amp;h.get_house_size());
        println!(&quot;\tHouse Plan\t:{:?}&quot;, &amp;h.details());
    }
}

#[derive(Debug)]
struct Room {
    name: String,
    room_size: i32,
}

#[derive(Debug)]
struct House {
    rooms: Vec&lt;Room&gt;,
}

#[derive(Debug)]
struct Street&lt;'a&gt; {
    houses: Vec&lt;Ref&lt;'a,House&gt;&gt;,
}

impl House {
    pub fn new() -&gt; House {
        House { rooms: Vec::new() }
    }

    pub fn get_house_size(&amp;self) -&gt; i32 {
        self.rooms.iter().map(|x| x.room_size).sum()
    }

    pub fn setup_house(mut self, bedrooms: i8, living_rooms: i8) -&gt; RefCell&lt;House&gt; {
        for i in 0..bedrooms {
            let bedroom: Room = Room {
                name: format!(&quot;bedroom number {}&quot;, i),
                room_size: 20,
            };
            self.rooms.push(bedroom);
        }

        for i in 0..living_rooms {
            let living_room: Room = Room {
                name: format!(&quot;living room number {}&quot;, i),
                room_size: 34,
            };
            self.rooms.push(living_room);
        }
        RefCell::new(self)
    }

    pub fn details(&amp;self) -&gt; Vec&lt;String&gt; {
        self.rooms.iter().map(|r| format!(&quot;{}: {}&quot;, &amp;r.name, &amp;r.room_size)).collect()
    }
}
</code></pre></pre>
<h1><a class="header" href="#lesson-sixteen-closure-patterns" id="lesson-sixteen-closure-patterns">Lesson Sixteen: Closure Patterns</a></h1>
<h2><a class="header" href="#objective-look-at-a-few-interesting-uses-of-closures" id="objective-look-at-a-few-interesting-uses-of-closures">Objective: Look at a few interesting uses of closures</a></h2>
<pre><pre class="playpen"><code class="language-rust">use std::fs::{self, DirEntry};
use std::io;
use std::path::Path;

fn main() {
    let proto_root = &quot;proto&quot;;
    build_protobufs(&amp;proto_root);
}

fn build_protobufs(proto_root: &amp;'static str) {
    let proto_buf_tests_root = Path::new(proto_root);
    visit_dirs(&amp;proto_buf_tests_root, &amp;process_entries::&lt;&amp;DirEntry&gt;).unwrap();
}

//This is our callback, invoked when a file is found.
fn process_entries&lt;F&gt;(f: &amp;DirEntry) {
    println!(&quot;Entry: {:?}&quot;, f);
    tonic_build::compile_protos(f.path()).unwrap();
}

// recursively get files
fn visit_dirs(dir: &amp;Path, cb: &amp;dyn Fn(&amp;DirEntry)) -&gt; io::Result&lt;()&gt; {
    if dir.is_dir() {
        for entry in fs::read_dir(dir)? {
            let entry = entry?;
            let path = entry.path();
            if path.is_dir() {
                visit_dirs(&amp;path, cb)?;
            } else {
                cb(&amp;entry);
            }
        }
    }
    Ok(())
}
</code></pre></pre>
<h1><a class="header" href="#lesson-sixteen-rc-refcell" id="lesson-sixteen-rc-refcell">Lesson Sixteen: Rc, RefCell</a></h1>
<h2><a class="header" href="#objectives-16" id="objectives-16">Objectives</a></h2>
<ul>
<li>Look at Rc, and RefCell </li>
</ul>
<p>Consider the following scenario:</p>
<p>A family of five has two parents and three grown-children.<br />
The grown-children all drive.<br />
The family has 3 cars: a Subaru, a Ferrari, and a Daihatsu Mira.</p>
<p>All members of the family can drive the Mira.
All members of the family can drive the Subaru.
Only the parents can drive the Ferrari.</p>
<table><thead><tr><th>Option</th><th>Details</th><th>Issue</th></tr></thead><tbody>
<tr><td>Clone</td><td>Makes a Copy</td><td>Lose shared state</td></tr>
<tr><td>Borrow with Lifetime Annotations</td><td>&amp;'a structs</td><td>None</td></tr>
<tr><td>Rc<T></td><td></td><td></td></tr>
</tbody></table>
<h3><a class="header" href="#rct" id="rct">Rc<T></a></h3>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
  --&gt; src/main.rs:47:26
   |
36 |     let house_d = House::new(2, &quot;Douglas&quot;.to_string());
   |         ------- move occurs because `house_d` has type `House`, which does not implement the `Copy` trait
...
44 |     street_0.houses.push(house_d);
   |                          ------- value moved here
...
47 |     street_1.houses.push(house_d);
   |                          ^^^^^^^ value used here after move

#}</code></pre></pre>
<h2><a class="header" href="#solution-one-lifetime-annoations" id="solution-one-lifetime-annoations">Solution One: Lifetime Annoations</a></h2>
<h2><a class="header" href="#solution-two-rct-reference-counting" id="solution-two-rct-reference-counting">Solution Two: Rc<T> Reference Counting</a></h2>
<p>The type Rc<T> provides shared ownership of a value of type T</p>
<p>{#playpen src/main.rs}}</p>
<p>Exercise</p>
<ul>
<li>Create a sample that mutates the contents of something behind a Rc<T></li>
</ul>
<h1><a class="header" href="#bit-fiddling" id="bit-fiddling">Bit Fiddling</a></h1>
<h1><a class="header" href="#lesson-nineteen-web-assembly" id="lesson-nineteen-web-assembly">Lesson Nineteen: Web Assembly</a></h1>
<h2><a class="header" href="#objectives-17" id="objectives-17">Objectives</a></h2>
<ul>
<li>Understand Web Assembly Essentials with Rust </li>
</ul>
<hr />
<h2><a class="header" href="#overview" id="overview">Overview</a></h2>
<p>Because of some limitations with javascript <em>and</em> to allow programmers to write web application code in other languages, web assembly (WASM) was approved and implemented. </p>
<p>Web Assembly is an intermediate language (il) that is currrently supported in all the major browsers. </p>
<p>Java and .NET programmers may be familiar with the il for their languages (msil for .NET and bytecode for Java).  Any dotnet or java code can be disassembled:</p>
<p>Here is HelloWorld in .NET 4.0:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Metadata version: v4.0.30319  
.assembly extern mscorlib  
{  
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..  
  .ver 4:0:0:0  
}  
.assembly Hello  
{  
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilationRelaxationsAttribute::.ctor(int32) = ( 01 00 08 00 00 00 00 00 )   
  .custom instance void [mscorlib]System.Runtime.CompilerServices.RuntimeCompatibilityAttribute::.ctor() = ( 01 00 01 00 54 02 16 57 72 61 70 4E 6F 6E 45 78   // ....T..WrapNonEx  
                                                                                                             63 65 70 74 69 6F 6E 54 68 72 6F 77 73 01 )       // ceptionThrows.  
  .hash algorithm 0x00008004  
  .ver 0:0:0:0  
}  
.module Hello.exe  
// MVID: {7C2770DB-1594-438D-BAE5-98764C39CCCA}  
.imagebase 0x00400000  
.file alignment 0x00000200  
.stackreserve 0x00100000  
.subsystem 0x0003       // WINDOWS_CUI  
.corflags 0x00000001    //  ILONLY  
// Image base: 0x00600000  

#}</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
(module
  (type (;0;) (func (result i32)))
  (type (;1;) (func (param i32)))
  (type (;2;) (func (param i32 i32)))
  (type (;3;) (func (param i32) (result i32)))
  (type (;4;) (func))
  (type (;5;) (func (param i32 i32) (result i32)))
  (type (;6;) (func (param i32 i32 i32)))
  (type (;7;) (func (param i32 i32 i32 i32) (result i32)))
  (type (;8;) (func (param i32 i32 i32) (result i32)))
  (import &quot;__wbindgen_placeholder__&quot; &quot;__wbindgen_describe&quot; (func (;0;) (type 1)))
  (import &quot;__wbindgen_placeholder__&quot; &quot;__wbg_alert_9b0fc9082f05403d&quot; (func (;1;) (type 2)))
  (import &quot;__wbindgen_anyref_xform__&quot; &quot;__wbindgen_anyref_table_grow&quot; (func (;2;) (type 3)))
  (import &quot;__wbindgen_anyref_xform__&quot; &quot;__wbindgen_anyref_table_set_null&quot; (func (;3;) (type 1)))
  (func (;4;) (type 4)
    call 25
    i32.const 11
    call 0
    i32.const 0
    call 0
    i32.const 1
    call 0
    i32.const 15
    call 0
    call 12
    call 11)
  (func (;5;) (type 4)
...
    i32.const 1048576
  (func (;8;) (type 6) (param i32 i32 i32)
#}</code></pre></pre>
<p><a href="https://asciinema.org/a/dLEdBBNjYLJYUjsJmBjFRjOKb">Screencast: Generating WAT (wasm in readable text format) from WASM</a></p>
<hr />
<h2><a class="header" href="#getting-started-with-wasm-in-rust" id="getting-started-with-wasm-in-rust">Getting Started with WASM in Rust</a></h2>
<p><a href="https://asciinema.org/a/QnwFimNAYwDZWPyBc8qfUJrbU">Video Overview: Getting Started with WASM in Rust</a></p>
<p>Rust has excellent support for web assembly.  In fact, there's a guide specifically for Rust and Web Assembly:</p>
<p>[Rust Web Assembly Book] (https://rustwasm.github.io/docs/book/introduction.html)</p>
<p>There are two primary ways to work with Web Assembly in Rust: <code>wasm-pack</code> and directly with <code>wasm-bindgen</code>. <code>wasm-pack</code> uses <code>wasm-bindgen</code> and provides tooling for npm integration.</p>
<p>The documentation takes you through the process of creating an web assembly and then using it on the web with npm packaging. </p>
<p>At a high-levl this is the process:</p>
<p>1 - Follow the instructions for <code>wasm-pack</code> installation <a href="https://rustwasm.github.io/docs/book/game-of-life/setup.html#the-rust-toolchain">wasm-pack</a> </p>
<p>2 - After setup, we create a new project with: the <code>cargo generate --git https://github.com/rustwasm/wasm-pack-template</code></p>
<p>3 - To build, we run: <code>wasm-pack build</code> and our package is output:  ```Your wasm pkg is ready to publish at ./pkg.``</p>
<p>4 - To web enable the app, from the main project directory (not .pkg), we run: <code>npm init wasm-app www</code>.</p>
<p>5 - We then cd into the <code>www</code> we just created and install our npm dependencies: <code>npm install</code></p>
<p>Running in Firefox:</p>
<p><img src="lessons/lesson_nineteen/artifacts/wasm_inff.png" alt="wasm running in firefox" /></p>
<hr />
<h3><a class="header" href="#the-basics-with-wasm-bindgen--webpack" id="the-basics-with-wasm-bindgen--webpack">The basics with <code>wasm-bindgen</code> + webpack</a></h3>
<p><code>NOTE: In the next two samples we are using npm with a plugin for webpack.  wasm has no dependency on npm</code></p>
<p>After npm install and npm build, the pkg directory is built:</p>
<pre><code class="language-bash">drwxr-xr-x     - john 19 Sep  7:09  pkg
.rw-r--r--    95 john 19 Sep  7:09    index.d.ts
.rw-r--r--  3.4k john 19 Sep  7:09    index.js
.rw-r--r--   244 john 19 Sep  7:09    index_bg.d.ts
.rw-r--r--   59k john 19 Sep  7:09    index_bg.wasm
.rw-r--r--   256 john 19 Sep  7:09    package.json
.rw-r--r--   407 john 19 Sep  7:09    README.md
.rw-r--r--   407 john 18 Sep 23:58  README.md
</code></pre>
<p>The process:
<code>webpack -&gt; index.js -&gt; ./pkg/</code></p>
<p><code>webpack config</code></p>
<pre><code class="language-javascript">const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const webpack = require('webpack');
const WasmPackPlugin = require(&quot;@wasm-tool/wasm-pack-plugin&quot;);

module.exports = {
    entry: './index.js',
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'index.js',
    },
    plugins: [
        new HtmlWebpackPlugin(),
        new WasmPackPlugin({
            crateDirectory: path.resolv

</code></pre>
<p><code>main.rs</code></p>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
use wasm_bindgen::prelude::*;
use wasm_bindgen::Clamped;
use web_sys::console::log;
use web_sys::{console, CanvasRenderingContext2d, ImageData};


#[wasm_bindgen]
pub fn transform_bird(
    ctx: &amp;CanvasRenderingContext2d,
    width: u32,
    height: u32,
) -&gt; Result&lt;(), JsValue&gt; {

    let mut data = render(width, height);
    let data = ImageData::new_with_u8_clamped_array_and_sh(Clamped(&amp;mut data), width, height)?;
    ctx.put_image_data(&amp;data, 0.0, 0.0)
}

fn render(width: u32, height: u32) -&gt; Vec&lt;u8&gt; {
    let mut data = Vec::new();

    data
}
#}</code></pre></pre>
<hr />
<h2><a class="header" href="#why-use-wasm" id="why-use-wasm">Why use WASM?</a></h2>
<p>The primary reasons for using <code>wasm</code> are:</p>
<p>1 - Use existing code libraries in a browser without rewriting them </p>
<p>2 - Letting developers work in their preferred language,</p>
<p>3 - Performance</p>
<h4><a class="header" href="#sample-library-in-wasm-eg-the-large-scientific-libraries-in-python-a-hrefhttpshacksmozillaorg201904pyodide-bringing-the-scientific-python-stack-to-the-browserpyodidea" id="sample-library-in-wasm-eg-the-large-scientific-libraries-in-python-a-hrefhttpshacksmozillaorg201904pyodide-bringing-the-scientific-python-stack-to-the-browserpyodidea">Sample library in WASM: e.g. the large scientific libraries in python: <a href="https://hacks.mozilla.org/2019/04/pyodide-bringing-the-scientific-python-stack-to-the-browser">pyodide</a></a></h4>
<hr />
<h2><a class="header" href="#performance-details" id="performance-details">Performance Details</a></h2>
<p>There's overhead associated with calls between the browser and a web assembly:</p>
<pre><code class="language-ru">            1              2
         ======&gt;        =====&gt;       \
Browser         WebWorker      Rust   ||
         &lt;======        &lt;=====      &lt;=/
            4              3
</code></pre>
<p><a href="https://stackoverflow.com/questions/53918351/is-there-a-performance-gain-to-use-web-sys-instead-of-plain-old-javascript">source</a></p>
<p>and we have some detailed analysis here:</p>
<p><a href="https://www.usenix.org/system/files/atc19-jangda.pdf">Performance Analysis: Native Code vs. WASM + asm.js</a></p>
<p>The rough conclusions from this research: is that WASM is ~1.2 - ~2x slower than native code and the details are very much dependent on the algorithm and datastructures.  asm.js out-performs plain JS ~1.3x, WASM out-performs asm.js ~1.3x, and native code out-performs WASM by ~1.2 to 2x. The same research also makes suggestions on optimizing WASM's code generation.</p>
<p>SIMD (single instruction multiple data) support (currently in beta for WASM) could massively increase performance for matrix-style operations. </p>
<hr />
<h2><a class="header" href="#known-limitations" id="known-limitations">Known Limitations:</a></h2>
<p>1 - Boxed by javascript, so the number of calls between <code>wasm</code> and <code>javascript</code> has a negative performance impact.</p>
<p>2 - Currently, no support for multi-threading.</p>
<p>3 - No native socket calls (but web api calls are supported)</p>
<p>4 - All the major browsers support WASM, but some do not.  (as a work-around, <a href="https://github.com/WebAssembly/binaryen">wasm2js</a> is a library to convert wasm to js)</p>
<p>Regarding the threading model, if you actually try to spawn a thread then it will panic, because wasm is single-threaded only right now.</p>
<p>However, most &quot;thread-specific&quot; things like Mutex, Arc, and atomics will work just fine.</p>
<p>They'll compile down into an efficient single-threaded implementation so it's only really spawning a thread which isn't supported right now.</p>
<hr />
<h2><a class="header" href="#the-bleeding-edge-wasmtime-and-wasi" id="the-bleeding-edge-wasmtime-and-wasi">The Bleeding Edge: Wasmtime and WASI</a></h2>
<p>There is a proposal to extend the he shared assembly standard beyond the browser.  The proposal is for <code>wasi</code> which is a runtime with file system access and other standard POSIX-like features, but securely sandboxed.</p>
<p>1 - <code>cargo new --bin demo</code> </p>
<p>2 - <code>rustup target add wasm32-wasi</code></p>
<p>3 - <code>cargo build --target wasm32-wasi</code></p>
<p>4 - install <a href="https://wasmtime.dev/">wasmtime</a> - a vm/runtime for wasm and wasi</p>
<p>5 - run the code above with: <code> wasmtime demo.wasm</code></p>
<hr />
<h2><a class="header" href="#resources" id="resources">Resources</a></h2>
<p>The web api samples here are excellent.  Some of the them are broken and evolving with the specication for wasm.  <a href="https://github.com/rustwasm/wasm-bindgen">bindgen</a></p>
<h3><a class="header" href="#exercise---similar-to-the-exercise-on-file-io-use-wasm-to-transform-an-image--there-is-a-skeleton-of-the-project-in-demoskhems_bird" id="exercise---similar-to-the-exercise-on-file-io-use-wasm-to-transform-an-image--there-is-a-skeleton-of-the-project-in-demoskhems_bird">Exercise - Similar to the exercise on File I/O, use wasm to transform an image.  There is a skeleton of the project in /demos/khems_bird/</a></h3>
<h1><a class="header" href="#lesson-twenty-working-with-threads" id="lesson-twenty-working-with-threads">Lesson Twenty: Working with Threads</a></h1>
<h2><a class="header" href="#objectives-18" id="objectives-18">Objectives</a></h2>
<ul>
<li>Understand the fundamental of working with threads in Rust </li>
</ul>
<hr />
<h2><a class="header" href="#overview-1" id="overview-1">Overview</a></h2>
<p>Working with threads in Rust is fun.  RC<T> and it's associates as well as mutability and borrowing let's us safely run native threads in Rust.</p>
<p>OO programmers most likely have seen or used threads in other languages, but typically on <code>green threads</code> fare supported in these languages.  That's a level of virtualization, and comes at a cost.</p>
<hr />
<h2><a class="header" href="#getting-started-with-threads-in-rust" id="getting-started-with-threads-in-rust">Getting Started with Threads in Rust</a></h2>
<p>Syntactically, Rust threads take a function, and it is common to see them in-lined with a closure as follows:</p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<hr />
<h3><a class="header" href="#thread-lifetimes" id="thread-lifetimes">Thread lifetimes</a></h3>
<ul>
<li>Importantly, when a parent thread is dropped, a child thread continues</li>
<li>The <code>.join()</code> function joins the thread of the current context and waits for its termination.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    drop(v); // oh no!

    handle.join().unwrap();
}
</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    println!(&quot;&quot;);
    let split = |n| {
        for _i in 1..n {
            print!(&quot;*&quot;);
        }
        println!(&quot;&quot;);
    };

    split(45);
    thread_lifetime();
}

//Note non-deterministic output
fn thread_lifetime() {

    let original_thread = thread::spawn(|| {
        let _detached_thread = thread::spawn(|| {
            // Here we sleep to make sure that the first thread returns before.
            thread::sleep(Duration::from_millis(10));
            // This will be called, even though the JoinHandle is dropped.
            println!(&quot; Still alive &quot;);
        });
    });

    original_thread
        .join() // &lt;- Waits for the associated thread to finish.
        .expect(&quot;The thread being joined has panicked&quot;);
    println!(&quot;Original thread is joined.&quot;);

    // We make sure that the new thread has time to run, before the main
    // thread returns.

    thread::sleep(Duration::from_millis(1000));
}
</code></pre></pre>
<h4><a class="header" href="#move-values-into-the-threads-closure" id="move-values-into-the-threads-closure">Move values into the Threads closure</a></h4>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
let k = [1, 2, 3];
    thread::spawn(|| { let n = k[0]; });  // &lt;- Compile Error
#}</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
let k = [1, 2, 3];
    thread::spawn(move || { let n = k[0]; }); 
#}</code></pre></pre>
<h2><a class="header" href="#channels---passing-data-between-threads" id="channels---passing-data-between-threads">Channels - passing data between threads</a></h2>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!(&quot;Got: {}&quot;, received);
}
</code></pre></pre>
<hr />
<h2><a class="header" href="#rayon-a-crate-for-parallelism" id="rayon-a-crate-for-parallelism">Rayon: A Crate for Parallelism</a></h2>
<p>One of the most popular crates in the Rust ecosystem is <a href="https://crates.io/crates/rayon">Rayon</a></p>
<p>With the addition of the crate, and the a simple change of the iterators to <code>_par_iter()</code> single-threaded iteration can changed to use multiple threads.</p>
<p>Below are two benchmarks, one for floating point processing and another with a hash initialization at 100 million iterations.</p>
<table><thead><tr><th>Function</th><th>Time</th></tr></thead><tbody>
<tr><td>sum_of_squares - fp</td><td><em>738.896ms</em></td></tr>
<tr><td>sum_of_squares_with_rayon -fp</td><td><em>531.016ms</em></td></tr>
<tr><td>mega_hash</td><td><em>678.212ms</em></td></tr>
<tr><td>mega_hash_with_rayon</td><td><em>198.15ms</em></td></tr>
</tbody></table>
<pre><pre class="playpen"><code class="language-rust">use rayon::prelude::*;
use std::collections::hash_map;
use std::collections::hash_map::RandomState;
use std::hash::BuildHasher;
use std::hash::{BuildHasherDefault, Hasher};
use std::time::{Duration, Instant};

const ITERATIONS: i32 = 100_000_000;


//This currently does not work with the Rust Playground as it pegs the CPU
fn main() {
    println!(&quot;Calling Function with Rayon parallel!&quot;);

    let start = Instant::now();
    let largish_array = get_squareables(ITERATIONS);
    let x = sum_of_squares(&amp;largish_array);
    let duration = start.elapsed();
    println!(&quot;Time elapsed in sum_of_squares() is: {:?}&quot;, duration);

    let start = Instant::now();
    let largish_array = get_squareables(ITERATIONS);
    let x = sum_of_squares_with_rayon(&amp;largish_array);
    let duration = start.elapsed();
    println!(
        &quot;Time elapsed in sum_of_squares_with_rayon() is: {:?}&quot;,
        duration
    );

    let start = Instant::now();
    let largish_array = get_hashables(ITERATIONS);
    let x = mega_hash(&amp;largish_array);
    let duration = start.elapsed();
    println!(&quot;Mega Hash() is: {:?}&quot;, duration);

    let start = Instant::now();
    let largish_array = get_hashables(ITERATIONS);
    let x = mega_hash_with_rayon(&amp;largish_array);
    let duration = start.elapsed();
    println!(&quot;Mega Hash with Rayon() is: {:?}&quot;, duration);
}

fn sum_of_squares_with_rayon(input: &amp;Vec&lt;f64&gt;) -&gt; f64 {
    input
        .par_iter() // &lt;-- just change that!
        .map(|i| i * i.sqrt().sin() / 3.0)
        .sum::&lt;f64&gt;()
}

fn sum_of_squares(input: &amp;Vec&lt;f64&gt;) -&gt; f64 {
    input.iter().map(|i| i * i.sqrt().asin() / 3.0).sum::&lt;f64&gt;()
}

fn mega_hash(input: &amp;Vec&lt;i64&gt;) -&gt; usize {
    use std::collections::HashMap;

    input
        .iter() // &lt;-- just change that!
        .map(|i| {
            let s = RandomState::new();
            let mut map: HashMap&lt;u64, u64&gt; = HashMap::with_hasher(s);
            (map.len())
        })
        .sum::&lt;usize&gt;()
}

fn mega_hash_with_rayon(input: &amp;Vec&lt;i64&gt;) -&gt; usize {
    use std::collections::HashMap;

    input
        .par_iter() // &lt;-- just change that!
        .map(|i| {
            let s = RandomState::new();
            let mut map: HashMap&lt;u64, u64&gt; = HashMap::with_hasher(s);
            (map.len())
        })
        .sum::&lt;usize&gt;()
}

fn get_squareables(terminus: i32) -&gt; Vec&lt;f64&gt; {
    (0..terminus).map(|x| f64::from(x)).collect()
}

fn get_hashables(terminus: i32) -&gt; Vec&lt;i64&gt; {
    (0..terminus).map(|x| i64::from(x)).collect()
}
</code></pre></pre>
<h1><a class="header" href="#lesson-twenty-one-async" id="lesson-twenty-one-async">Lesson Twenty-One: Async</a></h1>
<h2><a class="header" href="#objectives-19" id="objectives-19">Objectives</a></h2>
<ul>
<li>Understand the fundamental of the upcoming <code>async</code></li>
</ul>
<h2><a class="header" href="#understanding-runtimes" id="understanding-runtimes">Understanding Runtimes</a></h2>
<p>A runtime is an abstraction for a loop for an extended process.  Rust supports pluggable runtimes with the runtime attribute.</p>
<p>Note this line: <code>#[runtime::main]</code></p>
<pre><pre class="playpen"><code class="language-rust">/// Use the default Native Runtime
#[runtime::main]
async fn main() {}

/// Use the Tokio Runtime
#[runtime::main(runtime_tokio::Tokio)]
async fn main() {}
</code></pre></pre>
<h2><a class="header" href="#async-essentials" id="async-essentials">Async Essentials</a></h2>
<ul>
<li>It's not done! (Sept. 2019) - it's in nightly, but not in <code>stable</code></li>
<li>Methods must be marked by <code>async</code> keyword</li>
<li>Almost always for single-threaded scenarios </li>
<li>Nothing happens if <code>asnyc</code> functions are not awaited</li>
<li>await() methods return Futures</li>
</ul>
<h2><a class="header" href="#futures" id="futures">Futures</a></h2>
<p>The Tokio documentation has an excellent explanation of futures:</p>
<p>Trait tokio::prelude::Future</p>
<p>A future represents an asynchronous computation.</p>
<p>A future is a value that may not have finished computing yet. This kind of &quot;asynchronous value&quot; makes it possible for a thread to continue doing useful work while it waits for the value to become available.
The poll method</p>
<p>The core method of future, poll, attempts to resolve the future into a final value. This method does not block if the value is not ready. Instead, the current task is scheduled to be woken up when it's possible to make further progress by polling again. The context passed to the poll method can provide a Waker, which is a handle for waking up the current task.</p>
<p>When using a future, you generally won't call poll directly, but instead .await the value.</p>
<h2><a class="header" href="#a-sample-using-the-tokio-runtime-crate" id="a-sample-using-the-tokio-runtime-crate">A sample using the Tokio runtime crate</a></h2>
<pre><pre class="playpen"><code class="language-rust no_run">use tokio::net::TcpListener;
use tokio::prelude::*;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut listener = TcpListener::bind(&quot;127.0.0.1:8080&quot;).await?;

    loop {
        let (mut socket, _) = listener.accept().await?;

        tokio::spawn(async move {
            let mut buf = [0; 1024];

            // In a loop, read data from the socket and write the data back.
            loop {
                let n = match socket.read(&amp;mut buf).await {
                    // socket closed
                    Ok(n) if n == 0 =&gt; return,
                    Ok(n) =&gt; n,
                    Err(e) =&gt; {
                        println!(&quot;failed to read from socket; err = {:?}&quot;, e);
                        return;
                    }
                };

                // Write the data back
                if let Err(e) = socket.write_all(&amp;buf[0..n]).await {
                    println!(&quot;failed to write to socket; err = {:?}&quot;, e);
                    return;
                }
            }
        });
    }
}
</code></pre></pre>
<h1><a class="header" href="#basic-file-io-in-rust" id="basic-file-io-in-rust">Basic File I/O in Rust</a></h1>
<h2><a class="header" href="#opening-a-file-and-writing-some-data" id="opening-a-file-and-writing-some-data">Opening a file and writing some data</a></h2>
<pre><pre class="playpen"><code class="language-rust">use std::fs;
use std::io;
use std::io::{SeekFrom};
use std::io::prelude::*;

fn main() {
    let mut fp = fs::OpenOptions::new()
        .create(true)
        .write(true)
        .open(&quot;test.txt&quot;)
        .unwrap();
    
    fp.write_all(b&quot;1&quot;);
    fp.write_all(b&quot;2&quot;);
    fp.write_all(b&quot;3&quot;);
    fp.seek(SeekFrom::Start(0));
    fp.write_all(b&quot;4&quot;);
    fp.write_all(b&quot;5&quot;);
}
</code></pre></pre>
<h3><a class="header" href="#output-file-testtxt" id="output-file-testtxt">Output file (test.txt)</a></h3>
<pre><code>453
</code></pre>
<h3><a class="header" href="#points" id="points">Points</a></h3>
<ul>
<li>We use the <code>std::fs::OpenOptions</code> builder class to create a <code>File</code> (file handle object).</li>
<li><code>create(true)</code> - create a new file if t does not exist</li>
<li><code>write(true)</code> - open file with write permission</li>
<li>After calling <code>open(filepath)</code>, the builder class returns <code>Result&lt;File&gt;</code> - we can handle an error here</li>
<li><code>write_all</code> - get bytes as input, and write to file.</li>
<li>File handle cursor will be repositioned after calling <code>write_all</code>, but we can manually move it with the <code>seek</code> function (because <code>File</code> implement Trait <code>io::Seek</code>)</li>
<li><code>seek</code> receives a parameter <code>SeekFrom</code> object in 3 variants
<ul>
<li>Start(u64) : Seek from beginning of file</li>
<li>Current(u64) : Seek from current position of <code>Cursor</code></li>
<li>End(u64) : Current size of file plus position</li>
</ul>
</li>
<li>The file handle automatically closes after the lifetime of file handle object ends. (In C/C++ we need to call fclose(FILE *fp) manually)</li>
</ul>
<h2><a class="header" href="#serializedeserialize-file-by-json" id="serializedeserialize-file-by-json">Serialize/Deserialize file by JSON</a></h2>
<p>There's a wonderful library called <code>serde_json</code>. With this, we can easily/safely serialize/deserialize structured data to a text format.</p>
<pre><pre class="playpen"><code class="language-rust">use serde::{Deserialize, Serialize};
use serde_json::Result;
use std::fs;
use std::io::prelude::*;

#[derive(Debug, Serialize, Deserialize)]
enum Role {
    Attacker,
    Support,
    Tanker
}

#[derive(Debug, Serialize, Deserialize)]
struct Player {
    id: u32,
    name: String,
    role: Role
}

#[derive(Debug, Serialize, Deserialize)]
struct Party {
    name: String,
    members: Vec&lt;Player&gt;
}

fn main() {
    let alice = Player { id: 1, name: &quot;Alice&quot;.to_string(), role: Role::Support };
    let bob = Player { id: 2, name: &quot;Bob&quot;.to_string(), role: Role::Tanker };
    let prim = Player { id: 3, name: &quot;Primula&quot;.to_string(), role: Role::Attacker };

    let x = Party { name: &quot;For Fun&quot;.to_string(), members: vec!(alice, bob, prim) };

    let json = serde_json::to_string(&amp;x).unwrap();
    println!(&quot;{}&quot;, json);
    println!();

    {
        let mut fp = fs::OpenOptions::new()
            .create(true)
            .write(true)
            .open(&quot;party.json&quot;)
            .unwrap();
    
        fp.write_all(json.as_bytes());
    }

    let mut fp = fs::OpenOptions::new()
        .read(true)
        .open(&quot;party.json&quot;)
        .unwrap();
    
    let mut buffer = String::new();
    fp.read_to_string(&amp;mut buffer);

    let x_ds: Party = serde_json::from_str(&amp;buffer).unwrap();
    println!(&quot;{:?}&quot;, x_ds);
}
</code></pre></pre>
<h3><a class="header" href="#points-1" id="points-1">Points</a></h3>
<ul>
<li>We use <code>serde_json::to_string(&amp;str)</code> to encode struct to JSON, and in the same way, we use <code>serde_json::from_str(&amp;str)</code> to decode JSON back to struct.</li>
<li>To make structs serializable with serde, we need to <code>#[derive()]</code> the macro called <code>Serialize</code> and <code>Deserialize</code> for deserializing.</li>
</ul>
<h2><a class="header" href="#binary-file-with-rust" id="binary-file-with-rust">Binary File with Rust</a></h2>
<p>Saving a struct with Binary-Encoding in Rust can be done using library called <code>bincode</code> combined with <code>serde</code>'s macro. We migrate our previous code as follows:</p>
<pre><pre class="playpen"><code class="language-rust">use serde::{Deserialize, Serialize};
use std::fs;
use std::io::prelude::*;
use std::io::SeekFrom;

#[derive(Debug, Serialize, Deserialize)]
enum Role {
    Attacker,
    Support,
    Tanker
}

#[derive(Debug, Serialize, Deserialize)]
struct Player {
    id: u32,
    name: String,
    role: Role,
    money: u32
}

#[derive(Debug, Serialize, Deserialize)]
struct Party {
    name: String,
    members: Vec&lt;Player&gt;
}

fn main() {
    let alice = Player { id: 10, name: &quot;Alice&quot;.to_string(), role: Role::Support, money: 10 };
    let bob = Player { id: 1000, name: &quot;Bob&quot;.to_string(), role: Role::Tanker, money: 255 };
    let prim = Player { id: 100000, name: &quot;Primula&quot;.to_string(), role: Role::Attacker, money: 1000 };

    let x = Party { name: &quot;For Fun&quot;.to_string(), members: vec!(alice, bob, prim) };

    let bin = bincode::serialize(&amp;x).unwrap();
    println!(&quot;{:?}&quot;, bin);
    println!();

    let mut fp = fs::OpenOptions::new()
        .create(true)
        .write(true)
        .open(&quot;party.dat&quot;)
        .unwrap();

    fp.write_all(&amp;bin);
}
</code></pre></pre>
<h3><a class="header" href="#points-2" id="points-2">Points</a></h3>
<ul>
<li>Because the output file <code>party.dat</code> is binary file, we cannot open normally in a basic Text Editor (Actually, we can open but it may display badly and/or be missing lots of information)</li>
<li>To properly open binary files, we use a <code>Hex Editor</code>. there are many free ones:
<ul>
<li><a href="https://mh-nexus.de/en/hxd/">HxD</a></li>
<li><a href="https://hexed.it/">Online Hex Editor</a></li>
</ul>
</li>
</ul>
<h3><a class="header" href="#understanding-binary-encoding" id="understanding-binary-encoding">Understanding Binary Encoding</a></h3>
<p>Let's dig a bit deeper on the resulting <code>bincode</code> serialization.</p>
<p><img src="lessons/lesson_twenty_two/RustFSExample//hex.png" alt="Data in Hex" /></p>
<p>For those who may not familiar with hex editors, the two numbers in each of the columns represent one byte in file (in Haxadecimal). Let's look at our serialized struct <code>Party</code> again.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Party {
    name: String,
    members: Vec&lt;Player&gt;
}
#}</code></pre></pre>
<p>And let's compare with the first 15 bytes for file</p>
<pre><code>07 00 00 00 00 00 00 00 46 6F 72 20 46 75 6E
</code></pre>
<p>The part <code>46 6F 72 20 46 75 6E</code> in the bytes represents the ASCII number of String 'For Fun'. The first 8 bytes represents the length of this String. Someone may ask why use 8 bytes to store, it might be Rust (or bincode) use <code>u64</code> data format to store the lenght of string. (00 00 00 00 00 00 00 07 is 7 in decimal format)</p>
<p>Another interesting, why is its order reversed?! The reason is bincode respects the machine's <code>Memory Layout</code>, It's use the same layout, <code>u64</code>, as RAM storage.</p>
<p>Ok, let's see for next 8 bytes. It's <code>u64</code> again.  By using method above, we got </p>
<p>03 00 00 00 00 00 00 00 ---&gt; 3 (decimal)</p>
<p>This is the size of <code>Party.members</code> vector. <code>bincode</code> stores the size of vector before the real vector's content.</p>
<p>Now that we are familiar with binary files, let's take the next one more quickly. The first item in vector is a struct with data:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
Player { 
    id: 10,      // u32
    name: &quot;Alice&quot;.to_string(),      // lenght = 5
    role: Role::Support,        // u32's Enum (by default)
    money: 10                   // u32
}
#}</code></pre></pre>
<p>And here how stored in Hex form:</p>
<p><img src="lessons/lesson_twenty_two/RustFSExample//hex_alice.png" alt="Alice's Hex data" /></p>
<pre><code>0x0000000A = 10             ; id
0x0000000000000005 = 5      ; String.len()
0x416C696365 = 'Alice'      ;
0x00000001 = 1              ; Role::Support
0x0000000A = 10             ; money
</code></pre>
<p>I will leave the rest of the data for you to practice.</p>
<h2><a class="header" href="#cautions-about-using-binary-file" id="cautions-about-using-binary-file">Cautions about using binary file</a></h2>
<p>Binary files are smaller, and in most cases, faster than json serialization but there's some considerations: </p>
<ul>
<li>Binary files are hard to read by humans and cannot be modified by text editors.</li>
<li>If we change the structure of data, we can no longer use the saved file (without conversion or tweaking the read/write logic). For example:
<ul>
<li>Swap the order of struct's member</li>
<li>Change the size of struct's member</li>
</ul>
</li>
<li>It lacks a universal standard format comparing to JSON.</li>
</ul>
<h1><a class="header" href="#homework-playing-with-a-bmp-file" id="homework-playing-with-a-bmp-file">Homework (Playing with a BMP File)</a></h1>
<p>Let's create an <code>inverse</code> filter for <code>Bitmap File</code> (.bmp) by using Binary File I/O. </p>
<p>Your program reads an input bmp file, and creates an output bmp file, with the inverse filter applied.</p>
<p><img src="lessons/lesson_twenty_two/RustFSExample/filter.png" alt="Filter result" /></p>
<p>The Bitmap file is one of uncompressed image format. In this case we use a normal <code>24-bit RGB</code> image.
The File header(the beginning of file) of BMP File is 14 bytes long with this information</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    // MagicNumber: 2 bytes
    // FileSize: 4 bytes
    // Reserved: 4 bytes (not important)
    // StartAddress: 4 bytes
}
#}</code></pre></pre>
<p>two important values in here are <code>FileSize</code> and <code>StartAddress</code>.</p>
<p><code>FileSize</code> is the size of BMP File on disk, <code>StartAddress</code> is the start address of pixel data.</p>
<p>if you use hex editor to see the content at <code>StartAddress</code>, you will see each pixel data store in this pattern:</p>
<pre><code>[blue: u8] [green: u8] [red: u8] ....
</code></pre>
<p>The color in each RGB channel is stored in reverse order. And the byte order is from last row of pixels to first row of pixel. (Anyway, this is not important for our exercise)</p>
<p>To create an inverse filter, we have to invert the bit of pixel data in every bytes. (0 to 1, 1 to 0)</p>
<p>In rust, we can use the bitwise logical operator <code>!</code> </p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut x: u8 = 254u8;
x = !x              // x is now 1

// 254 (1111 1110) ---&gt; 1 (0000 0001)
#}</code></pre></pre>
<p>Ok, I hope you now have enough information to implement this program.</p>
<h3><a class="header" href="#hint" id="hint">Hint</a></h3>
<ul>
<li>In this case, we can skip working on Bitmap's DIB part (the content after header and before pixel data), but we still have to copy all of those bytes to output file.</li>
<li>You may have to use <code>seek</code> function</li>
</ul>
<p>More information about bitmap, you can look at <a href="https://en.wikipedia.org/wiki/BMP_file_format">wiki</a></p>
<h1><a class="header" href="#unsafe-code" id="unsafe-code">Unsafe Code</a></h1>
<h1><a class="header" href="#contributors" id="contributors">Contributors</a></h1>
<p><a href="https://mycostech.com">The Mycos Team</a></p>
<p><a href="https://github.com/etc3tera">Khem for Lesson 22 - Working with the File System</a></p>
<p><a href="https://github.com/Pauan">Pauan from the Rust and WebAssembly Working Group for comments on threading in wasm</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
